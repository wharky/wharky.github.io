---
layout: post
title: "프레임 단위의 신념: 격투 게임의 롤백 넷코드, 그 미친 동기화의 예술"
categories: tech
---

### ⚠️ Image Generation Failed
```text
Prompt: An artistic, glitchy rendering of a fighting game character performing a complex combo, surrounded by shimmering, translucent copies of themselves at slightly different positions, suggesting time travel and re-simulation. Intricate, glowing lines of network data weave through the scene, connecting a past state to a corrected future. The background is a digital clockwork mechanism, symbolizing precise frame timing and synchronization. Surreal, cyber-noir aesthetic.
```


안녕하세요, 시공간을 초월하는 미친 개발자, Dr. G입니다. 오늘도 제 폐쇄된 연구실, 아니, 블로그에 오신 여러분을 환영합니다! 오늘은 제 뇌 주름 사이에서 꿈틀거리는 가장 기이하고도 아름다운 개념 중 하나를 파헤쳐볼 겁니다: 바로 **격투 게임의 롤백 넷코드**죠.

"젠장, 핑 때문에 콤보 망쳤네!"
"아니, 분명 막았는데 왜 맞았지?"
"이거 텔레포트 격투 게임인가요?"

네, 지옥 같은 네트워크 환경에서 온라인 격투 게임을 플레이해본 사람이라면 누구나 겪었을 법한 분노의 외침들입니다. 텔레포트하는 상대, 내 마음과 다른 반응 속도… 이건 격투가 아니라 심령술이죠. 이런 고통을 해결하기 위해 우리 미친 개발자들은 시간의 흐름을 거스르는 금단의 마법을 개발했습니다. 이름하여 **롤백 넷코드 (Rollback Netcode)**!

---

### **문제의 본질: 지연 기반 넷코드의 한계**

전통적인 지연 기반(Delay-based) 넷코드는 간단합니다. 상대방의 입력이 도착할 때까지 내 입력을 대기시키는 방식이죠. 마치 국회의원들이 결정을 내릴 때까지 모두가 숨죽이고 기다리는 것과 같습니다. 핑이 50ms라면, 내 입력은 50ms 후에야 게임에 반영됩니다. 100ms면? 100ms죠. 격투 게임에서 1프레임(약 16ms)은 생사여탈을 가르는데, 50ms는 거의 3프레임 지연입니다. 3프레임이면 웬만한 가드, 회피, 반격 타이밍을 통째로 날려 먹는 수준이죠.

"이게 격투냐, 리듬게임이지!" – 플레이어들의 울부짖음이 들리는 듯합니다.

---

### **롤백, 시간 여행자의 선택**

롤백 넷코드는 다릅니다. 얘는 기다리지 않습니다. "어? 상대방 입력이 아직 안 왔네? 그럼 뭐… **내 맘대로 예측해서 실행하자!**" 이렇게 게임을 진행합니다. 그러다가 나중에 *진짜* 상대방의 입력이 도착하면, 과거로 돌아가서 자신이 했던 예측이 맞았는지 틀렸는지 확인합니다. 만약 틀렸다면? "흠, 내가 좀 성급했군. 그럼 잠시 시간을 되돌려서… 옳게 된 미래를 다시 만들자!" 하고 게임 상태를 되감아 재시뮬레이션하는 겁니다.

이게 바로 **'낙관적 실행(Optimistic Execution)'** 의 마법입니다. 네트워크 지연을 없애는 대신, 예측과 보정을 통해 체감 지연을 '0'에 가깝게 만드는 것이죠. 물론 마냥 공짜는 아닙니다. 이 미친 짓에는 필연적으로 대가가 따릅니다.

---

### **심층 해부: 롤백의 내부 기관들**

롤백 넷코드가 작동하는 원리를 조금 더 깊게 파고들어 봅시다. 준비됐습니까? 뇌정지가 올 수도 있습니다!

1.  **프레임 고정 게임 로직 (Deterministic Game Logic)**
    *   가장 중요합니다. 게임의 모든 시뮬레이션은 어떤 상황에서도 **항상 같은 입력이 주어지면 같은 결과를 내야 합니다.** 부동 소수점 오차, `rand()` 함수 사용, 멀티 스레딩 문제, 심지어 OS나 CPU 아키텍처 차이까지, 모든 비결정적 요소를 제거해야 합니다. 만약 A 컴퓨터에서 '주먹' 입력이 '펀치'를 발생시키고, B 컴퓨터에서 '발차기'를 발생시킨다면? 롤백은 의미가 없습니다. 이는 개발자의 자살 행위나 다름없죠.

2.  **게임 상태 저장 (State Saving)**
    *   게임을 예측 실행하기 전에, 우리는 현재 게임의 완벽한 스냅샷(게임 상태)을 저장해야 합니다. 캐릭터의 위치, 체력, 히트박스, 투사체, 심지어 RNG 시드값까지, 나중에 정확히 되돌릴 수 있도록 모든 것을 기록해야 합니다. 이걸 매 프레임마다 합니다! 상상해보십시오. 매 프레임 킬로바이트 단위의 데이터를 저장하고 불러오는 오버헤드. 이건 게임이 아니라 데이터 백업 시스템입니다!

3.  **입력 예측 (Input Prediction)**
    *   상대방의 입력이 아직 도착하지 않았다? 그럼 예측해야죠. 가장 간단한 방법은 "상대방은 마지막에 했던 행동을 계속한다" 또는 "상대방은 아무것도 하지 않는다(Idle)"고 가정하는 겁니다. 물론 이건 거의 틀립니다. 인간은 예측 불가능한 존재니까요. 하지만 우리는 일단 실행합니다.

4.  **검증 및 수정 (Verification & Correction)**
    *   드디어 상대방의 진짜 입력이 네트워크를 타고 도착했습니다. 우리는 이 진짜 입력과 우리가 이전에 예측했던 입력을 비교합니다. 만약 예측이 맞았다면? 아무 문제 없습니다. 훌륭한 예언자시군요!
    *   **만약 틀렸다면?** "젠장, 예언 능력이 망했군!" 우리는 마지막으로 올바르게 동기화되었던 프레임(또는 상대방 입력이 도착한 프레임)으로 게임 상태를 **롤백(Rollback)**합니다. 그리고 그 프레임부터 *진짜* 입력값을 사용해 현재 프레임까지 게임을 **재시뮬레이션(Re-simulate)**합니다. 이 과정에서 화면의 캐릭터들은 과거로 돌아갔다가 현재로 순간이동하는 것처럼 보이겠죠. (예: 뿅!)

---

### **괴짜 박사의 의사코드 (Pseudo-code)**

너무 이론적이라고요? 좋습니다, 괴짜 박사의 머릿속에서 나온 엉망진창이지만 동작하는 의사코드를 보시죠!

```
// 전역 변수 (개발자의 고통이 담겨 있음)
GameWorldState HistoryBuffer[BUFFER_SIZE]; // 게임 상태를 저장할 버퍼
int CurrentFrame = 0; // 현재 게임 프레임
int LastConfirmedFrame = -1; // 양쪽 플레이어가 동기화된 마지막 프레임

// 게임 루프: 매 프레임마다 실행
function GameLoop()
    // 1. 현재 게임 상태 저장 (과거를 준비하는 자세)
    HistoryBuffer[CurrentFrame % BUFFER_SIZE] = SaveCurrentGameState();

    // 2. 입력 처리 (로컬은 내 맘대로, 원격은 예측!)
    LocalInput = GetLocalPlayerInput();
    RemoteInput = PredictRemotePlayerInput(CurrentFrame); // 상대는 뭘 할까? 찍어!

    // 3. 게임 프레임 실행
    ExecuteGameFrame(LocalInput, RemoteInput);

    // 4. 네트워크에서 원격 입력이 도착했는지 확인
    if (RemoteInputPacketArrived())
        remote_actual_input = GetRemoteInputFromPacket();
        remote_input_frame = GetFrameNumberFromPacket();

        // 5. 예측이 틀렸는지 확인 (불길한 순간)
        if (remote_input_frame > LastConfirmedFrame && 
            IsPredictionWrong(remote_input_frame, remote_actual_input))
            
            // 6. 롤백 시작! (시간을 되돌리는 미친 짓)
            RollbackAndReSimulate(remote_input_frame, remote_actual_input);
            LastConfirmedFrame = remote_input_frame; // 이제 이 프레임은 확정!

    // 7. 다음 프레임으로 이동 (인생은 계속된다)
    CurrentFrame++;

// -----------------------------------------------------------

function RollbackAndReSimulate(divergence_frame, correct_remote_input)
    // 1. 과거로 돌아가기 (타임머신 탑승!)
    LoadGameState(HistoryBuffer[divergence_frame % BUFFER_SIZE]);

    // 2. 정확한 입력으로 재시뮬레이션 (옳게 된 미래!)
    for frame_to_resimulate from divergence_frame to CurrentFrame
        // 재시뮬레이션 중에는 로컬 입력은 저장된 것, 원격 입력은 'correct_remote_input' 사용
        resim_local_input = GetLocalInputFromHistory(frame_to_resimulate); // 로컬도 저장해둬야 함!
        resim_remote_input = (frame_to_resimulate == divergence_frame) ? correct_remote_input : PredictRemotePlayerInput(frame_to_resimulate);
        
        ExecuteGameFrame(resim_local_input, resim_remote_input);
        
        // 재시뮬레이션된 상태 다시 저장 (미래를 덮어쓰기!)
        HistoryBuffer[frame_to_resimulate % BUFFER_SIZE] = SaveCurrentGameState(); 

    // 화면 업데이트: 순간이동 효과를 부드럽게 (플레이어를 안심시켜야 함)
    SmoothVisualCorrection();

// -----------------------------------------------------------

function PredictRemotePlayerInput(frame_num)
    // 여기에서 예측 로직 구현 (가장 어려운 부분)
    // 예: "그냥 마지막에 쓴 기술을 또 쓴다고 가정할까?"
    // 예: "이동 중이면 계속 이동한다고 가정할까?"
    // 아니면 그냥 "아무것도 안 한다"고 가정하고 나중에 롤백으로 때울 수도... (무책임)
    return LastKnownRemoteInput; 

function IsPredictionWrong(frame_num, actual_input)
    // 저장된 과거의 예측과 실제를 비교 (슬픈 진실)
    return HistoryBuffer[frame_num % BUFFER_SIZE].PredictedRemoteInput != actual_input;

function SmoothVisualCorrection()
    // 롤백으로 인해 캐릭터가 튀는 현상을 보정하는 마법
    // 예: 몇 프레임에 걸쳐 자연스럽게 위치를 보간 (interpolation)
    // 예: 순간적으로 화면을 흔들거나 효과를 넣어 눈속임
    // 실제로는 눈에 띄지 않게 처리하는 게 가장 중요! (개발자의 자존심)
```

---

### **개발자의 비명: 롤백의 함정들**

이 모든 마법에도 불구하고, 롤백 넷코드는 개발자에게 새로운 지옥을 선물합니다.

*   **스테이트 스프로울 (State Sprawl):** 저장해야 할 게임 상태가 너무 많아지면 메모리와 CPU 오버헤드가 미쳐 날뛰죠. 압축, 델타 인코딩, 똑똑한 직렬화 기법이 필수입니다. "야, 이 캐릭터 옷 주름까지 저장해야 한다고?"
*   **비결정성 버그 (Non-Deterministic Bugs):** 이건 개발자의 최악의 악몽입니다. "내 컴퓨터에선 완벽하게 되는데, 왜 다른 개발자 컴퓨터에서는 콤보가 끊겨요?!" 부동 소수점 오차, 최적화 컴파일러 설정, 타이밍 문제… 이놈들은 숨어있다가 결정적인 순간에 튀어나와 개발자의 정신을 파괴합니다.
*   **시각적 아티팩트 (Visual Artifacts):** 아무리 롤백이 잘 작동해도, 너무 잦은 롤백은 화면에서 캐릭터가 '뿅!' 하고 튀는 것처럼 보일 수 있습니다. 이걸 최소화하기 위해 시각적인 보간(Interpolation)이나 미묘한 카메라 쉐이크 같은 눈속임 기법이 필요하죠. "내 눈이 이상한가? 순간이동한 것 같은데…?"
*   **입력 지연 vs. 롤백 빈도:** 예측이 너무 자주 틀리면 롤백이 너무 많이 발생해서 게임이 뚝뚝 끊기는 것처럼 보입니다. 결국 최적의 예측 알고리즘과 롤백 임계값을 찾는 것은 예술의 경지입니다.

---

### **결론: 그럼에도 불구하고**

롤백 넷코드는 복잡하고, 지옥 같고, 비결정성 버그의 무덤이지만, 현대 온라인 격투 게임의 표준으로 자리 잡았습니다. 이 기술 덕분에 우리는 광활한 인터넷 바다를 건너 전 세계의 플레이어들과 거의 완벽하게 동기화된, **'프레임 단위의 신념'**을 공유하는 진정한 격투를 즐길 수 있게 되었죠.

만약 다음에 온라인 격투 게임에서 깔끔한 콤보를 성공시키거나, 상대의 간발의 차이로 막아냈다면, 잠시 네트워크 엔지니어와 롤백 넷코드를 구현한 개발자들에게 경의를 표해주십시오. 그들은 여러분의 찰나의 승리를 위해 시공간을 조작하는 미친 과학 기술을 개발했으니까요!

그럼, 다음에는 또 어떤 괴상한 개발 기술로 여러분의 뇌를 뒤흔들지 기대해주세요! Dr. G는 또 다른 미친 프로젝트를 찾아 떠납니다! 뿅! (사라지는 효과음)
