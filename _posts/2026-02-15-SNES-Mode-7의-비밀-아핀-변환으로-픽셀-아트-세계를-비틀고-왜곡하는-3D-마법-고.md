---
layout: post
title: "SNES Mode 7의 비밀: 아핀 변환으로 픽셀 아트 세계를 비틀고 왜곡하는 3D 마법 (고전 게임 엔진 개발자를 위한 실전 가이드)"
categories: tech
---

### ⚠️ Image Generation Failed
```text
Prompt: A vibrant pixel art rendering of a futuristic racing game track, reminiscent of SNES F-Zero or Mario Kart, with a ground that appears to curve and rotate in pseudo-3D due to Mode 7 affine transformations. The perspective is dynamic, showing a distinct "bending" of the 2D background, with colorful sprites of retro cars zipping across it. The overall aesthetic is nostalgic and technically impressive, highlighting the cleverness of vintage hardware tricks.
```

안녕, 개발 동지들! 오늘도 커피 들이키고 모니터 앞에 붙어 있겠지? 나는 가끔 똥폼 잡고 먼지 쌓인 슈퍼패미컴을 쳐다보며 과거의 위대한 해킹 기술에 경탄하곤 해. 왜냐고? 현대의 GPU에 밀리지 않는(물론 속도 말고 '아이디어' 면에서!) 광기의 코딩 아트가 숨어있거든. 오늘은 그중에서도 슈퍼패미컴(SNES)의 전설적인 마법, **Mode 7**에 대해 딥다이브 해볼 거야. 겉만 핥는 이야기는 사양한다!

---

### **Mode 7, 그게 뭔데? (진짜 3D 아니었어?)**

"F-Zero"의 쌩쌩 달리는 트랙, "젤다의 전설 신들의 트라이포스" 월드맵의 웅장한 회전... 어릴 적 내 눈에는 그게 진짜 3D인 줄 알았지. 근데 아니었어! Mode 7은 SNES의 PPU(Picture Processing Unit)가 제공하는 특수한 백그라운드 모드 중 하나야. 단 하나의 백그라운드 레이어에만 적용되는데, 이 레이어의 픽셀을 그릴 때 **아핀 변환(Affine Transformation)**이라는 수학적 마법을 걸 수 있도록 해주는 거야.

쉽게 말해, 하나의 거대한 2D 텍스처(배경 맵)를 준비하고, 이걸 화면에 그릴 때 각 픽셀마다 "야, 너는 저기 텍스처의 (x, y) 좌표에서 가져와!"라고 지시할 수 있는 능력이지. 그리고 이 "어디서 가져올지"를 회전, 확대/축소, 왜곡해서 계산해 버리는 거야. 이게 마치 진짜 3D처럼 보이게 하는 착시 현상을 일으키는 핵심이야. 머리는 2D인데 눈은 3D로 속는 기분? 개발자 입장에서는 짜릿하지!

---

### **마법의 주문: 아핀 변환의 내부 (Feat. SNES 레지스터)**

Mode 7의 핵심은 PPU가 각 화면 픽셀(screen_x, screen_y)에 대해, 실제 백그라운드 텍스처의 어느 좌표(source_x, source_y)를 샘플링할지 계산하는 공식에 있어. 이 계산에 사용되는 녀석들이 바로 M7A, M7B, M7C, M7D, M7X, M7Y 레지스터들이야.

이 레지스터들의 값은 8비트 정수부에 8비트 소수부를 가지는 **고정 소수점(Fixed-Point) 방식**으로 저장돼. `>> 8` 연산은 소수점 부분을 제거하고 정수부만 취하는 역할을 하지. 이 고정 소수점 연산은 당시 제한적인 CPU 성능으로 부동 소수점 연산을 흉내 내기 위한 필수적인 트릭이었어. (아, 눈물 없이는 볼 수 없는 최적화의 역사!)

**코어 아핀 변환 공식 (PPU가 각 픽셀에 대해 계산하는 방식):**

```pseudocode
// 재료 키워드: Retro Console Architecture, Develop Technique of Retro Nintendo Games

// 고정 소수점 이동량 (8비트 정수부, 8비트 소수부 = 총 16비트)
// 예를 들어, 1.0은 FP_ONE (256)으로 표현됨. 0.5는 FP_ONE/2 (128)
DEFINE FIXED_POINT_SHIFT = 8
DEFINE FP_ONE = 1 << FIXED_POINT_SHIFT // 256

// 화면 해상도 (SNES 기준)
DEFINE SCREEN_WIDTH = 256
DEFINE SCREEN_HEIGHT = 224

// PPU가 각 화면 픽셀 (screen_x, screen_y)에 대해, 실제 배경 맵 좌표를 계산하는 핵심 함수
// M7_A, M7_B, M7_C, M7_D, M7_X, M7_Y는 현재 스캔라인에 설정된 고정 소수점 레지스터 값.
FUNCTION CalculateMode7SourceCoords(screen_x, screen_y, M7_A, M7_B, M7_C, M7_D, M7_X, M7_Y) RETURNS (source_x_fp, source_y_fp)
    // Mode 7 변환의 '중심점'이 되는 화면 좌표.
    // F-Zero와 같은 원근감 효과에서, 이 점은 보통 화면의 중앙이거나 바닥의 중앙 지점이 됨.
    // SNES PPU는 이 기준점을 활용하여 dx, dy를 계산함.
    DEFINE MODE7_SCREEN_CENTER_X = SCREEN_WIDTH / 2;
    DEFINE MODE7_SCREEN_CENTER_Y = SCREEN_HEIGHT / 2; // 또는 맵의 투시 기준에 따라 조절

    // 화면 픽셀을 Mode 7 변환의 중심점으로부터의 상대 좌표로 변환
    int dx_relative = screen_x - MODE7_SCREEN_CENTER_X;
    int dy_relative = screen_y - MODE7_SCREEN_CENTER_Y;

    // 핵심 아핀 변환 공식! (모든 변수는 고정 소수점 값으로 처리됨)
    // source_x_fp는 배경 맵의 x 좌표 (고정 소수점)
    // source_y_fp는 배경 맵의 y 좌표 (고정 소수점)
    // M7_X, M7_Y는 배경 맵에서 (MODE7_SCREEN_CENTER_X, MODE7_SCREEN_CENTER_Y)에 해당하는 월드 좌표.
    int source_x_fp = ((M7_A * dx_relative + M7_B * dy_relative) >> FIXED_POINT_SHIFT) + M7_X;
    int source_y_fp = ((M7_C * dx_relative + M7_D * dy_relative) >> FIXED_POINT_SHIFT) + M7_Y;

    RETURN (source_x_fp, source_y_fp);
END FUNCTION

// PPU는 이 함수를 화면의 각 픽셀 (screen_x, screen_y)마다 호출하여
// 해당 픽셀에 그릴 배경 맵의 픽셀 좌표를 얻는다고 생각하면 됨.
// 반환된 source_x_fp, source_y_fp를 다시 >> FIXED_POINT_SHIFT 하면 실제 픽셀 좌표가 나옴.
// (예: actual_x = source_x_fp >> FIXED_POINT_SHIFT)
```

자, 여기까지는 그냥 아핀 변환의 기본이야. 진짜 마법은 여기서부터 시작돼.

---

### **진짜 마법: 스캔라인마다 변하는 레지스터 값! (유사 3D 트릭)**

SNES PPU는 화면을 위에서 아래로 한 줄(스캔라인)씩 그려나가. 이 특징을 이용해서, **각 스캔라인을 그릴 때마다 M7A-D, M7X-Y 레지스터 값을 바꿔줄 수 있었어!** 이게 F-Zero 같은 게임에서 3D 원근감을 만들어내는 핵심 트릭이야.

화면의 위쪽 스캔라인은 "멀리 떨어진 곳"으로, 아래쪽 스캔라인은 "가까운 곳"으로 보이도록 만들어야 하잖아? 그러려면 화면의 Y 좌표(스캔라인)에 따라 스케일(M7A, M7D)을 조절하고, 원근 기준점(M7X, M7Y)을 이동시켜야 해. 이게 바로 SNES 개발자들이 2D 하드웨어로 3D를 "사기 쳤던" 방법이지! (역시 사기가 제일 재미있어!)

**F-Zero 스타일 '바닥' 원근감 구현을 위한 의사코드 (각 스캔라인마다 레지스터 값 계산):**

```pseudocode
// 전역 카메라 상태 (게임 로직에서 업데이트)
GLOBAL float camera_world_x, camera_world_y; // 카메라의 월드 좌표
GLOBAL float camera_angle_rad;               // 카메라의 회전 각도 (라디안)

// Mode 7 관련 상수
DEFINE SCREEN_WIDTH = 256
DEFINE SCREEN_HEIGHT = 224 // SNES 해상도
DEFINE HORIZON_Y = SCREEN_HEIGHT / 3 // 화면 Y축 상의 가상 지평선 (대략)
DEFINE INITIAL_MODE7_SCALE = 1.0f    // 기본 스케일 (적절히 조절)
DEFINE MIN_SCALE_FACTOR = 0.005f     // 최소 스케일 (너무 멀리 있는 것)
DEFINE MAX_SCALE_FACTOR = 20.0f      // 최대 스케일 (너무 가까이 있는 것)

FUNCTION RenderMode7Background()
    // 8.8 고정 소수점 스케일링 상수
    DEFINE FP_ONE = 256
    DEFINE FIXED_POINT_SHIFT = 8

    // 각 스캔라인마다 PPU 레지스터에 쓸 값을 계산
    FOR scanlineY FROM 0 TO SCREEN_HEIGHT - 1
        // --- 1. 이 스캔라인의 '월드 깊이' 계산 (핵심!) ---
        // 화면 Y좌표가 지평선(HORIZON_Y)에서 멀어질수록 '가까워지는' 효과를 냄.
        // `effective_depth_on_plane` 값이 실제 월드 좌표 상의 '거리'를 흉내 냄.
        // (scanlineY - HORIZON_Y)가 클수록 화면 아래쪽에 위치하며, 이는 '더 가까운' 지점을 나타냄.
        float effective_depth_on_plane = MAX(1.0f, (float)scanlineY - HORIZON_Y);

        // 깊이에 따라 스케일 팩터 조절 (멀수록 작게, 가까울수록 크게)
        float current_scale = INITIAL_MODE7_SCALE / effective_depth_on_plane;
        current_scale = CLAMP(current_scale, MIN_SCALE_FACTOR, MAX_SCALE_FACTOR);

        // --- 2. 카메라 회전 및 스케일을 반영하여 M7A-D 계수 계산 (고정 소수점) ---
        // M7A, M7B, M7C, M7D는 회전 및 스케일 행렬을 구성함.
        // 이 값들은 `current_scale`에 따라 매 스캔라인마다 달라진다!
        int m7a_reg = (int)(cos(camera_angle_rad) * current_scale * FP_ONE);
        int m7b_reg = (int)(sin(camera_angle_rad) * current_scale * FP_ONE);
        int m7c_reg = (int)(-sin(camera_angle_rad) * current_scale * FP_ONE);
        int m7d_reg = (int)(cos(camera_angle_rad) * current_scale * FP_ONE);

        // --- 3. M7X, M7Y '카메라' 위치 계산 (고정 소수점) ---
        // M7X, M7Y는 해당 스캔라인에서 화면의 "중심점"이 배경 맵의 어디에 해당하는지를 나타냄.
        // 카메라의 월드 좌표를 기준으로, 현재 스캔라인의 '깊이'와 '회전'을 고려하여 계산.
        // 이 계산은 게임의 카메라 모델에 따라 크게 달라질 수 있지만, 기본적인 아이디어는 다음과 같음.
        // (screen_width/2)와 (scanlineY - HORIZON_Y)가 화면상의 상대 위치를 나타내며,
        // 이를 current_scale로 나누면 월드 공간에서의 상대적인 크기를 얻게 됨.
        float screen_center_relative_x = (SCREEN_WIDTH / 2.0f);
        float screen_center_relative_y = (float)scanlineY; // 이 스캔라인의 화면 Y 위치

        // 스캔라인의 깊이와 카메라 회전을 고려하여 M7X, M7Y (월드 좌표)를 설정
        // 이 부분은 카메라의 3D 공간에서의 위치와 투영 방식에 따라 복잡해짐.
        // 여기서는 직관적인 예시를 위해 단순화된 계산을 사용.
        // (camera_world_x, camera_world_y)는 게임 세계에서 카메라가 위치한 지점.
        // M7X, M7Y는 그 카메라 지점이 화면 특정 위치(MODE7_SCREEN_CENTER)에 나타나도록 하는 월드 좌표.
        // 따라서 카메라 월드 좌표에서 화면의 중심을 월드 좌표로 변환한 값을 빼야 함.
        int m7x_reg = (int)( (camera_world_x -
                              (cos(camera_angle_rad) * screen_center_relative_x - sin(camera_angle_rad) * effective_depth_on_plane) / current_scale) * FP_ONE);
        int m7y_reg = (int)( (camera_world_y -
                              (sin(camera_angle_rad) * screen_center_relative_x + cos(camera_angle_rad) * effective_depth_on_plane) / current_scale) * FP_ONE);

        // --- 4. PPU 레지스터 업데이트 (가상) ---
        // SNES는 HBlank 인터럽트 등을 통해 스캔라인이 그려지는 중간에 레지스터 값을 업데이트할 수 있었어.
        // 실제 에뮬레이터나 하드웨어에서는 이 레지스터 값을 PPU에 쓰는 매크로나 함수를 호출함.
        // Set_SNES_PPU_Mode7_Registers(m7a_reg, m7b_reg, m7c_reg, m7d_reg, m7x_reg, m7y_reg);

        // 이 스캔라인의 모든 픽셀은 방금 설정된 M7 레지스터 값을 사용하여 PPU에 의해 그려짐.
        // PPU는 내부적으로 CalculateMode7SourceCoords 함수와 유사하게 각 픽셀의 소스를 계산하여 그림.
    END FOR
END FUNCTION
```

위의 의사코드가 SNES Mode 7이 어떻게 유사 3D를 구현하는지 보여주는 핵심이야. 각 스캔라인마다 `effective_depth_on_plane`이라는 값을 계산하고, 이 값에 따라 스케일과 기준점(M7X, M7Y)을 바꿔주지. 마치 2D 슬라이스를 여러 개 쌓아서 3D처럼 보이게 하는 기법이지. 현대 셰이더 프로그래밍에서도 유사한 아이디어를 적용할 수 있어! (옛날 코딩 스킬이 현대에도 통하는 마법이라니!)

---

### **고전 게임 명작들의 Mode 7 유산**

Mode 7은 단순히 기술적인 트릭을 넘어, 당시 게임 디자인에 엄청난 영향을 끼쳤어. "F-Zero"가 보여준 시원한 속도감, "마리오 카트"의 아기자기한 트랙, "젤다의 전설 신들의 트라이포스"에서 월드맵이 빙글빙글 돌아가는 연출은 Mode 7이 없었다면 불가능했을 거야.

이 기술 덕분에 개발자들은 제한된 하드웨어 자원 속에서도 깊이감과 역동성을 표현할 수 있었고, 이는 곧 게임의 재미로 이어졌지. 지금의 우리가 아무렇지도 않게 쓰는 3D 그래픽 엔진은 당시 개발자들의 이런 '미친 발상'과 '집념'이 쌓여 만들어진 산물이라고!

---

### **그래서, 오늘날의 인디 게임 개발자에게 Mode 7은 왜 중요할까?**

"요즘은 유니티나 언리얼에 3D 기능이 다 있는데, 이걸 왜 알아야 하냐?"라고 물을 수 있겠지. 멍청한 질문이야! 물론 요즘에는 진짜 3D를 쓰지만, Mode 7은 여전히 강력한 무기가 될 수 있어.

1.  **독특한 레트로 미학**: 진짜 3D로는 흉내 낼 수 없는, 비틀리고 왜곡된 Mode 7 특유의 '맛'이 있어. 이걸 잘 활용하면 다른 인디 게임과는 차별화된 시각적 아이덴티티를 만들 수 있지.
2.  **퍼포먼스 최적화**: 저사양 기기나 웹 기반 게임에서 굳이 고성능 3D 렌더링을 돌릴 필요 없이, 2D 스프라이트 기반 위에 Mode 7 셰이더를 입히면 훨씬 가볍고 빠르게 유사 3D 효과를 낼 수 있어.
3.  **창의적인 디자인**: 제한된 환경에서 창의력이 폭발하는 법! Mode 7의 원리를 이해하면, 단순히 트랙을 만드는데 그치지 않고, 왜곡된 거울 효과, 환각적인 배경, 독특한 UI/UX 요소 등 훨씬 더 기발한 아이디어를 구현할 수 있을 거야.

그러니까, 단순히 과거의 유물이 아니라, 오늘날의 인디 개발자들이 자신의 게임에 '미친 천재성'을 불어넣을 수 있는 강력한 아이디어의 원천이라는 거지!

---

어때? 비록 복잡한 고정 소수점 연산과 스캔라인 트릭에 머리가 좀 아팠겠지만, 이 모든 과정이 옛 개발자들이 얼마나 치열하게 '속이는' 기술을 연구했는지 보여주잖아. 다음번에 F-Zero를 다시 플레이할 때는, 단순한 경주 게임이 아니라, 픽셀과 수학으로 엮어낸 예술 작품으로 보일 거야.

자, 이제 너의 다음 인디 게임에 Mode 7의 영혼을 불어넣어 볼 시간이야! 오늘 밤은 맥주 한 캔과 함께 SNES 에뮬레이터 코드나 뜯어보자고!

_끝._
