---
layout: post
title: "PS1의 덜덜거리는 텍스처를 2024년에 재현하기: 현대 쉐이더로 구현하는 레트로 버그아트"
categories: tech
---

### ⚠️ Image Generation Failed
```text
Prompt: A surreal, glitchy 3D scene inspired by PlayStation 1 aesthetics. A distorted, wobbly landscape made of low-polygon triangles, with textures that appear to swim and stretch. A vibrant, retro-futuristic color palette with neon accents against a dark, foggy background, evoking a sense of nostalgic digital art and the unique visual artifacts of early 3D consoles.
```

아, 옛날이여! 그 깍두기 그래픽, 그 덜덜거리는 텍스처! 요즘 친구들은 "버그"라고 하겠지만, 우리 괴짜 아재 개발자들은 알지. 그게 바로 하나의 예술이자, 당시 하드웨어의 한계가 빚어낸 독특한 매력이었다는 것을!

오늘은 시간 여행을 떠나, 무려 1994년 12월 3일에 출시된 위대한 소니 플레이스테이션 1(PS1)의 아이코닉한 "덜덜이" 그래픽을 현대 쉐이더로 완벽하게 복제하는 비법을 파헤쳐볼 겁니다. 왜냐고요? 글쎄, 요즘 갬성 터지는 인디 게임 개발에 필요한 건 쨍한 4K 해상도가 아니라, 이런 아날로그 감성이 아닐까? 물론, 근본을 이해하면 어떤 그래픽이든 뚝딱 만들어낼 수 있다는 자신감은 덤이죠!

---

### Deep Dive: PS1의 "덜덜이" 텍스처, 대체 왜 그랬을까?

결론부터 말하면, PS1의 "덜덜이"는 **제한된 부동 소수점 정밀도**와 **어파인(Affine) 텍스처 매핑**이라는 두 가지 핵심 요소가 만들어낸 합작품입니다. 요즘 게임 개발자들에겐 당연한 이 "버그"의 원리를 파고들어 봅시다.

#### 1. 고정 소수점(Fixed-Point) 연산과 버텍스 스내핑(Vertex Snapping)

PS1은 지금의 우리가 쓰는 부동 소수점(Floating-Point) 연산 대신 고정 소수점 연산을 주로 사용했습니다. 이 말은 즉, 3D 오브젝트의 위치를 계산할 때 '소수점' 부분이 제한적이라는 뜻이죠.

*   **원리:** PS1의 GPU는 3D 공간상의 버텍스(정점) 위치를 스크린 공간으로 투영할 때, 이 위치들을 가장 가까운 **정수 픽셀 좌표**로 "스냅"하는 경향이 있었습니다. 즉, '픽셀의 중간' 같은 애매한 위치가 아니라, '딱 떨어지는 픽셀'에 버텍스를 고정시켰죠.
*   **결과:** 카메라가 움직이거나 오브젝트가 회전할 때, 버텍스들이 미세하게 '움찔'거리면서 한 픽셀씩 뚝뚝 끊어지는 듯한 움직임을 보였습니다. 이게 바로 오브젝트 자체가 덜덜거리는 주된 이유 중 하나입니다. "아니, 나는 부드럽게 움직였는데 왜 화면에선 로봇처럼 삐그덕대지?!" 바로 이것 때문이죠.

#### 2. 어파인(Affine) 텍스처 매핑의 비극 (혹은 미학!)

이것이 바로 "텍스처 수영(Texture Swimming)" 또는 "텍스처 워블(Texture Wobble)"의 근본 원인입니다. 현대 GPU는 '원근 보정(Perspective Correct)' 텍스처 매핑을 수행하지만, PS1은 주로 어파인 매핑을 사용했습니다.

*   **현대 GPU (원근 보정):** 텍스처 좌표(UV)를 보간할 때, 각 픽셀의 깊이(Z 값)를 고려하여 멀리 있는 부분은 텍스처가 더 조밀하게 압축되도록 합니다. 마치 멀리 있는 벽돌이 작고 많아 보이는 것처럼요. (쉽게 말해 UV를 Z로 나눠서 보간)
*   **PS1 GPU (어파인 매핑):** 텍스처 좌표(UV)를 보간할 때, **깊이(Z 값)를 제대로 고려하지 않고** 삼각형의 스크린 공간 상에서 UV를 선형적으로 보간했습니다. 쉽게 말해, 가까이 있는 부분과 멀리 있는 부분의 텍스처 밀도가 똑같이 느껴지도록 보간하는 겁니다.
*   **결과:** 카메라에 비스듬하게 놓인 폴리곤이나, 깊이 차이가 큰 넓은 폴리곤을 보면 텍스처가 마치 물 위를 떠다니는 것처럼 흐느적거리거나 왜곡되어 보이는 현상이 발생했습니다. 멀리 있는 텍스처가 가까이 있는 텍스처와 동일한 스케일로 늘어져 버리는 거죠. "분명히 벽돌 무늬였는데, 왜 저기선 고무판처럼 늘어나지?!" 바로 이것 때문입니다!

수많은 개발자들이 이 수학적 고통 속에서 밤새도록 곱씹었던 그 한계를, 이제 우리는 "갬성"이라는 이름으로 재현하고자 합니다. 크하하!

---

### Code & Logic: 현대 쉐이더로 "덜덜이" 예술 구현하기

자, 이제 이 "버그"들을 현대 그래픽스 파이프라인에서 어떻게 재현할지 알아봅시다. 우리는 GLSL 쉐이더를 사용하여 버텍스 스내핑과 어파인 텍스처 매핑의 시각적 효과를 구현할 겁니다.

핵심 아이디어는 간단합니다.

1.  **버텍스 스내핑:** 버텍스 쉐이더에서 오브젝트의 위치를 화면 공간이나 뷰 공간에서 정수 값에 가깝게 강제로 '뚝뚝 끊어' 놓는 겁니다.
2.  **어파인 텍스처 워블:** 프래그먼트 쉐이더에서 텍스처 UV를 보간할 때, 픽셀의 깊이(Z)와 스크린 좌표를 활용하여 원근 보정이 안 된 것처럼 왜곡을 가하는 겁니다.

#### **1. 버텍스 쉐이더 (Vertex Shader)**

```glsl
#version 330 core
layout (location = 0) in vec3 aPos;         // 모델의 로컬 공간 위치
layout (location = 1) in vec2 aTexCoord;    // 모델의 텍스처 좌표

uniform mat4 model;
uniform mat4 view;
uniform mat4 projection;
uniform float u_geomSnapSize;       // 버텍스 스내핑 강도 (예: 0.05)
uniform float u_pixelSnapThreshold; // 픽셀 스내핑 임계값 (예: 320.0, 가상 해상도)

out vec2 v_texCoord;
out float v_viewSpaceZ; // 프래그먼트 쉐이더로 전달할 뷰 공간 Z 값

void main() {
    // 1. 모델 공간 -> 뷰 공간 변환
    vec4 viewPos = view * model * vec4(aPos, 1.0);

    // 2. 버텍스 스내핑 (Geometry Jitter)
    // 뷰 공간에서 버텍스 좌표를 강제로 '뚝뚝' 끊습니다.
    // 카메라가 움직이거나 오브젝트가 회전할 때 버텍스가 덜덜거리는 효과를 줍니다.
    if (u_geomSnapSize > 0.0) {
        viewPos.x = floor(viewPos.x / u_geomSnapSize) * u_geomSnapSize;
        viewPos.y = floor(viewPos.y / u_geomSnapSize) * u_geomSnapSize;
        // Z축 스내핑은 깊이 순서 문제를 일으킬 수 있으므로 주의해서 사용.
        // 여기서는 부드러운 깊이 정렬을 위해 Z 스내핑은 생략합니다.
    }

    // 3. 최종 클립 공간 위치 계산
    gl_Position = projection * viewPos;

    // 4. 텍스처 좌표와 뷰 공간 Z 값을 프래그먼트 쉐이더로 전달
    v_texCoord = aTexCoord;
    v_viewSpaceZ = viewPos.z; // v_viewSpaceZ는 선형 보간될 것임!
}
```

*   **`u_geomSnapSize`:** 이 값이 클수록 버텍스가 더 거친 그리드에 스냅되어 오브젝트가 더 심하게 덜덜거립니다.
*   **`v_viewSpaceZ`:** 이 값은 프래그먼트 쉐이더로 전달될 때, 현대 GPU에 의해 "선형적"으로 보간됩니다. 이 선형 보간된 Z 값이 바로 어파인 텍스처 매핑의 시각적 효과를 재현하는 핵심입니다. (원래 현대 GPU는 1/Z를 보간해서 Z를 복원하지만, 여기서는 Z 자체를 보간해서 그 선형성을 이용합니다.)

#### **2. 프래그먼트 쉐이더 (Fragment Shader)**

```glsl
#version 330 core
out vec4 FragColor;

in vec2 v_texCoord;
in float v_viewSpaceZ; // 버텍스 쉐이더에서 선형 보간되어 넘어온 뷰 공간 Z

uniform sampler2D u_textureSampler;
uniform float u_affineWobbleStrength; // 어파인 텍스처 워블 강도 (예: 0.01)
uniform vec2 u_resolution;            // 현재 렌더링 해상도 (gl_FragCoord.xy와 함께 사용)

void main() {
    vec2 finalUV = v_texCoord;
    
    // 1. 어파인 텍스처 워블 (Texture Wobble/Swim) 구현
    // 선형 보간된 v_viewSpaceZ를 이용하여 텍스처 UV를 왜곡합니다.
    // |v_viewSpaceZ| 값이 클수록 (카메라에서 멀어질수록) 왜곡이 커집니다.
    // 이는 PS1의 어파인 매핑이 깊이를 고려하지 않아 멀리 있는 텍스처가 비정상적으로 늘어지는 현상과 유사한 시각적 효과를 줍니다.

    float depthFactor = 1.0 / (abs(v_viewSpaceZ) + 0.0001); // 0으로 나누는 것 방지, 멀수록 큰 값
    depthFactor = clamp(depthFactor * 5.0, 0.0, 1.0); // 스케일 조정 및 클램핑

    // 스크린 좌표에 따라 UV를 왜곡하여 '수영하는' 느낌을 줍니다.
    // gl_FragCoord.xy는 현재 픽셀의 스크린 좌표입니다.
    vec2 screen_uv_norm = gl_FragCoord.xy / u_resolution; // [0,1] 범위로 정규화된 스크린 좌표

    // 이 부분은 PS1의 실제 하드웨어 동작을 완벽히 모방하는 것이 아니라,
    // 그로 인해 발생하는 시각적 '덜덜이' 효과를 재현하는 '트릭'입니다.
    // linearly interpolated screen space UVs will look similar to this.
    vec2 wobbleOffset = (screen_uv_norm - 0.5) * depthFactor * u_affineWobbleStrength;

    finalUV += wobbleOffset;

    // 2. 최종 텍스처 샘플링
    FragColor = texture(u_textureSampler, finalUV);
}
```

*   **`v_viewSpaceZ`:** 이 값은 뷰 공간에서의 픽셀 깊이를 나타냅니다. 버텍스 쉐이더에서 선형 보간되어 넘어왔기 때문에, 이 값을 이용하면 PS1의 어파인 매핑과 유사하게 깊이에 따라 비례적으로 왜곡되는 텍스처를 만들 수 있습니다.
*   **`u_affineWobbleStrength`:** 이 값이 클수록 텍스처 왜곡이 심해져 더 심하게 "수영"하는 것처럼 보입니다.
*   **`screen_uv_norm - 0.5`:** 텍스처 왜곡의 기준점을 스크린 중앙으로 잡고, 중앙에서 멀어질수록 왜곡이 심해지도록 만듭니다.

---

### Wit & Sense: "버그 아트"의 매력, 그리고 개발자의 고뇌

솔직히 말해서, 이 쉐이더 코드는 PS1 GPU의 내부 로직을 100% 완벽하게 에뮬레이션하는 것은 아닙니다. 현대 GPU의 파이프라인은 PS1과는 너무나 달라서, 진짜 PS1처럼 만들려면 에뮬레이터를 통째로 쉐이더로 포팅해야 할 겁니다! 하지만 이 코드는 PS1 특유의 시각적 "덜덜이" 효과를 **매우 설득력 있게** 재현하는, 개발자들의 오랜 지혜가 담긴 "트릭"이자 "핵"이라고 할 수 있습니다.

우리는 흔히 이런 "버그"들을 없애기 위해 밤을 지새우지만, 때로는 그 버그 자체가 시대를 상징하는 예술이 되기도 합니다. PS1의 그래픽은 당시 기술의 한계 속에서 개발자들이 어떻게든 3D를 구현하려 했던 눈물겨운 노력의 산물이었고, 그 한계가 만들어낸 독특한 미학은 오늘날 레트로 감성을 자극하는 강력한 무기가 되었죠.

PS1의 "덜덜이" 외에도 Z-파이팅(Z-fighting, 깊이 버퍼 정밀도 부족으로 인해 같은 위치에 있는 두 폴리곤이 번갈아 깜빡이는 현상), 저해상도 렌더링, 제한된 컬러 팔레트 등 다양한 그래픽적 특징들이 있었습니다. 이런 모든 것들이 합쳐져 'PS1스러움'을 만들어냅니다. 여러분의 인디 게임을 만들 때, 이런 디테일들을 깊이 있게 파고들어 사용한다면, 플레이어들에게 단순히 '옛날 게임 같다'를 넘어 '어떤 특별한 경험'을 제공할 수 있을 겁니다.

자, 이제 여러분의 인디 게임을 90년대 유물처럼 보이게 할 시간입니다! 쨍한 그래픽만 쫓는 시대는 가라! "버그 아트"의 정수를 이해하고, 이를 통해 자신만의 독창적인 비주얼 스타일을 만들어 보세요. 이거시 바로 예술이 아니면 무엇이란 말인가! 크하하하!
