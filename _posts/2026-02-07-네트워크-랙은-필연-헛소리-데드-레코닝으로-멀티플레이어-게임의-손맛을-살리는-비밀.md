---
layout: post
title: "네트워크 랙은 필연? 헛소리! 데드 레코닝으로 멀티플레이어 게임의 '손맛'을 살리는 비밀"
categories: tech
---

### ⚠️ Image Generation Failed
```text
Prompt: A conceptual, high-tech digital art piece depicting the essence of network synchronization in real-time multiplayer games. Dynamic composition showing ghostly, fragmented character models moving across a grid-like, futuristic battlefield. Intersecting lines of light represent data packets and prediction algorithms. One dominant character is clearly defined, representing the client's predicted state, while fainter, lagging shadows show server corrections. There should be subtle visual glitches and artifacts to symbolize latency. Dominant colors are deep blues, electric purples, and neon greens, with sharp, dramatic chiaroscuro lighting casting long shadows. Cyberpunk aesthetic with a sense of urgent, precise calculation. Focus on the abstract beauty of data flow and the challenge of temporal synchronization. High resolution, detailed.
```
> 서버 문제로 이미지가 로드되지 않았습니다. 위 프롬프트를 참고하세요.


얘들아, 오랜만이야! 다들 잘 지내고 있냐?
오늘은 내가 너희가 온라인 게임을 개발하면서 언젠가 반드시 맞닥뜨릴, 아니 어쩌면 벌써 머리를 싸매고 있을지도 모를 **'네트워크 랙'**이라는 지긋지긋한 문제에 대한 이야기를 좀 해줄까 해. 특히, 단순히 핑이 높아서 느리다는 차원을 넘어, **진짜 '손맛'이 살아있는 실시간 멀티플레이어 게임**을 만들기 위한 핵심 비법, 바로 **데드 레코닝(Dead Reckoning)**에 대해서 말이야.

초보 개발자들은 흔히 "랙은 그냥 인터넷 문제 아닌가요?" 하고 묻곤 해. 그 말도 틀린 건 아니지만, 그걸 그대로 받아들이면 너희 게임은 절대 시장에서 살아남을 수 없어. 유저들은 **지연(Latency)**이라는 물리적 한계를 인지하면서도, 마치 로컬 게임처럼 즉각적인 반응을 기대한단 말이지. 우리가 할 일은 그 기대를 충족시켜주는 '마법'을 부리는 거야.

---

### 1. 지연(Latency)의 폭정: 왜 데드 레코닝이 필요한가?

생각해봐. 네 캐릭터가 총을 쐈어. 이 정보는 네 컴퓨터에서 서버로 전송되고, 서버는 이 정보를 처리한 다음 다른 모든 클라이언트에 "플레이어 A가 총을 쐈다!"고 알려주지. 이 과정에 걸리는 시간이 바로 **왕복 지연 시간(RTT, Round Trip Time)**이야. 짧게는 수십 밀리초(ms)지만, 길게는 수백 ms까지도 갈 수 있어.

이 짧은 지연 시간조차도 실시간 게임에서는 치명적이야.
*   "내가 분명히 먼저 쐈는데 왜 내가 죽었지?"
*   "적 캐릭터가 순간이동하는 것 같아!"
*   "내 캐릭터가 내가 누른 키보다 한 박자 늦게 움직여!"

이 모든 불만은 네트워크 지연 때문에 발생해. 특히 1인칭 슈팅(FPS) 게임이나 대전 격투 게임처럼 **정밀한 입력과 즉각적인 피드백**이 중요한 장르에서는 이 문제가 극대화되지. 여기서 데드 레코닝이 등장하는 거야.

---

### 2. 죽은 자의 항해? 아니, '예측'의 마법: 데드 레코닝의 기본

**데드 레코닝(Dead Reckoning)**은 원래 선박이나 항공기에서 현재 위치를 과거 위치와 이동 속도, 방향을 기반으로 추정하는 항해 기술 용어였어. 이걸 게임 네트워크 동기화에 차용한 건데, 핵심은 바로 **'예측(Prediction)'**과 **'보정(Correction)'**이야.

기본 원리는 간단해.
1.  **클라이언트 예측 (Client-Side Prediction)**: 내 컴퓨터(클라이언트)는 내가 입력하는 모든 행동을 즉시 화면에 반영해. 서버에서 응답이 오기까지 기다리지 않는 거지. 내가 앞으로 이동하라고 키를 누르면, 즉시 내 캐릭터는 앞으로 움직여.
2.  **서버 조정 (Server Reconciliation)**: 서버는 모든 클라이언트의 입력을 받아서 게임의 '진정한' 상태를 계산하고, 주기적으로 각 클라이언트에 현재의 진실된 상태(Server Snapshot)를 보내줘.
3.  **오류 보정 (Error Correction)**: 클라이언트는 서버에서 받은 진실된 상태와 자신이 예측한 상태를 비교해. 만약 차이가 있다면, 그 차이를 부드럽게 보정해서 화면에 보여주는 거야.

이렇게 하면 유저는 자기 캐릭터에 한해서는 **지연을 거의 느끼지 못하고 즉각적인 반응성**을 경험할 수 있어. 마치 싱글 플레이 게임처럼 말이지.

---

### 3. 심층 분석: 데드 레코닝, 어떻게 구현할 것인가?

자, 이제 좀 더 깊이 들어가 보자. 데드 레코닝은 단순히 움직이는 것을 예측하는 수준을 넘어, 다양한 기술적 고려사항이 필요해.

#### 3.1. 클라이언트 예측: Input Buffering과 Command Queue

클라이언트는 플레이어의 입력을 받으면 즉시 그 입력에 따라 캐릭터의 상태(위치, 회전, 애니메이션 등)를 업데이트해. 이때 중요한 건, 단순히 현재 상태만 업데이트하는 게 아니라, **어떤 입력으로 인해 이 상태가 되었는지 기록**해두는 거야. 이걸 보통 **Input Buffer**나 **Command Queue**라고 불러.

```cpp
// 가상의 클라이언트 Update 함수
void ClientPlayer::Update(float deltaTime) {
    // 1. 현재 프레임의 입력 처리 및 Input Buffer에 저장
    Input currentInput = GetPlayerInput();
    inputBuffer.Add(currentInput);

    // 2. 버퍼링된 입력에 따라 로컬 플레이어 상태 예측 업데이트
    ApplyInputToLocalPlayer(currentInput, deltaTime); 
    // 예: transform.position += transform.forward * moveSpeed * deltaTime;

    // 3. (옵션) 다른 플레이어는 최신 서버 상태 기반으로 보간/외삽
    for (RemotePlayer player : remotePlayers) {
        player.InterpolateOrExtrapolate(deltaTime); 
    }

    // 4. 서버로부터 새로운 스냅샷이 도착했는지 확인
    if (networkManager.HasNewServerSnapshot()) {
        ServerSnapshot latestSnapshot = networkManager.GetLatestServerSnapshot();
        ReconcileLocalPlayer(latestSnapshot); // 서버 조정 단계
    }
}
```

#### 3.2. 서버 조정: Replay System의 마법

서버는 각 클라이언트로부터 입력을 받으면, 해당 클라이언트가 **'어떤 입력 시점(Tick)'**에 그 입력을 발생시켰는지 함께 전달받아. 서버는 모든 클라이언트의 입력을 모아 자신의 **'진정한' 게임 상태(Authoritative State)**를 한 틱(Tick)씩 계산해나가.

그리고 주기적으로 (예: 초당 20~60회) 각 클라이언트에 현재 서버의 진실된 상태인 **스냅샷(Snapshot)**을 전송해줘. 이 스냅샷에는 각 플레이어 객체의 위치, 회전, HP, 애니메이션 상태 등 **모든 핵심 정보**가 담겨 있어.

클라이언트가 이 스냅샷을 받으면, 자신이 예측했던 상태와 서버의 진실된 상태를 비교하는 과정이 필요해.
1.  **입력 버퍼 정리**: 서버 스냅샷에 포함된 '처리된 입력 틱(Processed Input Tick)'보다 오래된 로컬 입력은 버퍼에서 제거해. 이미 서버가 처리한 입력이니까.
2.  **상태 비교**: 자신의 현재 예측 위치와 서버 스냅샷에 담긴 자신의 위치를 비교해.
3.  **오차 발생 시 보정**: 만약 오차가 크다면 (예: `RECONCILIATION_THRESHOLD` 이상), 클라이언트는 **서버의 위치로 강제 이동(Snapping)**하거나, 남아있는 입력 버퍼를 사용하여 **서버 스냅샷 시점부터 다시 시뮬레이션(Re-simulation)**을 수행해야 해. 다시 시뮬레이션하는 방식이 훨씬 부드럽지만 복잡해.

```cpp
// 가상의 클라이언트 Reconcile 함수
void ClientPlayer::ReconcileLocalPlayer(ServerSnapshot snapshot) {
    // 1. 서버 스냅샷에서 내 캐릭터의 상태를 찾기
    PlayerState serverState = snapshot.GetPlayerState(myPlayerId);

    // 2. 서버가 처리한 틱까지의 입력은 버퍼에서 제거
    inputBuffer.DiscardInputsUpToTick(serverState.processedInputTick);

    // 3. 서버 상태와 예측 상태 비교
    if (Vector3.Distance(transform.position, serverState.position) \u003e RECONCILIATION_THRESHOLD) {
        // 4. 오차가 크면 서버 상태로 보정
        transform.position = serverState.position;
        transform.rotation = serverState.rotation;

        // 5. 남아있는 입력으로 다시 시뮬레이션하여 부드럽게 이어 붙이기
        ReSimulateRemainingInputs(inputBuffer); 
    }
}
```

#### 3.3. 다른 플레이어 처리: 보간 (Interpolation)과 외삽 (Extrapolation)

내 캐릭터는 예측과 보정으로 처리하지만, 다른 플레이어(Remote Player) 캐릭터는 서버에서 오는 스냅샷을 기반으로 동기화해야 해. 이때 두 가지 기법이 주로 사용돼.

*   **보간(Interpolation)**: 서버에서 받은 *두 개의 연속된 스냅샷* 사이의 시간을 이용해서 부드럽게 움직임을 이어주는 거야. 예를 들어, 스냅샷 A와 B를 받았다면, 클라이언트는 현재 시간과 A, B의 시간 차이를 이용해 A와 B 사이의 어느 지점에 캐릭터가 있어야 할지 계산하지. 이건 움직임이 **부드럽다**는 장점이 있지만, 필연적으로 **약간의 지연(Latency Hiding Buffer)**이 발생해. 최신 상태보다 살짝 뒤처져 보이는 거지.

*   **외삽(Extrapolation)**: 마지막으로 받은 스냅샷의 위치와 속도 정보를 기반으로, 앞으로 캐릭터가 어디에 있을지 **미리 추정**해서 보여주는 방식이야. 보간보다 즉각적인 움직임을 보여줄 수 있지만, 서버에서 새로운 스냅샷이 도착했을 때 예측이 빗나갔다면 **갑작스러운 위치 이동(Snapping)**이 발생할 수 있어. 갑자기 적이 텔레포트한 것처럼 보일 수도 있다는 말이지.

어떤 것을 선택할지는 게임의 종류와 중요도에 따라 달라져. 보통 이동이 예측 가능한 AI 캐릭터는 외삽을, 플레이어 캐릭터는 보간을 사용하여 부드러움을 우선시하기도 해. 하지만 FPS처럼 즉각적인 피드백이 중요한 경우, 약간의 스내핑을 감수하고 외삽을 사용하는 경우도 많아.

---

### 4. 더 깊은 인사이트: 물리(Physics), 애니메이션, 상태 동기화

데드 레코닝은 단순히 캐릭터 위치 동기화를 넘어, 게임 내 다양한 요소에 적용될 수 있어.

*   **물리 시뮬레이션**: 클라이언트와 서버의 물리 시뮬레이션이 **결정론적(Deterministic)**이어야 해. 즉, 동일한 입력과 초기 상태가 주어지면 항상 동일한 결과가 나와야 한다는 거지. 이를 위해 고정 소수점 연산이나 정해진 물리 엔진 버전을 사용하는 등의 노력이 필요해. 서버에서 발사체 충돌 결과를 보내주면, 클라이언트는 그 시점의 상태를 재구성해서 충돌을 '재현'하는 식으로 동기화할 수 있어.
*   **애니메이션**: 서버는 캐릭터의 '상태' (예: '달리기', '점프', '공격 중')를 전송하고, 클라이언트는 이 상태에 맞는 애니메이션을 재생해. 여기에 약간의 지연 보상 로직을 추가하여 부드러운 전환을 만들 수 있지.
*   **게임 상태 (Gameplay State)**: HP, 스킬 쿨타임, 아이템 사용 여부 등 비주얼이 아닌 순수 게임 로직 상태도 스냅샷에 포함시켜 동기화해야 해.

가장 중요한 건, **서버가 언제나 '진실(Authority)'을 갖고 있어야 한다**는 점이야. 클라이언트는 어디까지나 유저 경험을 위한 '예측'일 뿐, 최종적인 게임 진행은 서버의 결정에 따라야 해. 클라이언트가 멋대로 자신의 HP를 변경하거나, 아이템을 생성하는 등의 핵(Hack)을 방지하기 위함이지.

---

### 5. 최적화의 예술: 데드 레코닝 튜닝

데드 레코닝은 만능이 아니야. 너무 공격적인 예측은 잦은 스내핑을 유발하고, 너무 보수적인 예측은 다시 지연을 느끼게 해. 결국, 게임의 특성과 목표에 맞춰 끊임없이 **튜닝**해야 하는 영역이지.

*   **`RECONCILIATION_THRESHOLD`**: 얼마만큼의 오차가 발생해야 보정을 할 것인가? 이 값에 따라 스내핑의 빈도와 예측의 정확도가 달라져.
*   **`INTERPOLATION_BUFFER_TIME`**: 다른 플레이어 캐릭터를 보간할 때, 얼마나 과거의 정보를 이용할 것인가? 이 시간이 길수록 부드럽지만 지연이 심해져.
*   **네트워크 대역폭**: 스냅샷의 빈도와 포함되는 데이터의 양은 곧 네트워크 대역폭 사용량으로 연결돼. 꼭 필요한 정보만 최소한의 크기로 압축해서 보내는 노하우가 필요해.
*   **Packet Loss, Jitter**: 예측과 보정 로직은 단순히 고정된 핑 환경이 아닌, 패킷 손실(Packet Loss)이나 핑 변동(Jitter)과 같은 실제 네트워크 환경에서도 안정적으로 동작하도록 설계되어야 해.

이 모든 요소를 고려해서 개발해야만, 유저들이 "와, 이 게임은 핑이 높아도 렉이 하나도 없네!"라고 착각하게 만들 수 있는, **진정으로 '손맛'이 살아있는 멀티플레이어 게임**을 만들 수 있어.

---

### 6. 마무리: 너희의 도전을 응원하며

어때? 데드 레코닝, 단순히 텍스트로만 봐도 머리가 좀 아프지? 하지만 이 모든 복잡한 과정은 결국 단 하나의 목표를 향하고 있어. 바로 **"플레이어에게 최고의 경험을 제공하는 것."**

솔직히 말해서, 이 개념을 완벽하게 이해하고 구현하려면 많은 시행착오를 겪을 거야. 나도 처음엔 그랬어. 하지만 이 원리를 한번 제대로 이해하고 나면, 네트워크 동기화라는 거대한 퍼즐의 조각들이 맞춰지는 듯한 희열을 느낄 수 있을 거다.

네트워크 프로그래밍은 게임 개발의 꽃 중 하나라고 생각해. 보이지 않는 곳에서 게임의 근본적인 재미를 지탱하는 중요한 기술이니까. 겁먹지 말고, 직접 부딪혀보면서 자신만의 해결책을 찾아나가길 바라. 언젠가 너희가 만든 게임에서, 지연 따위는 존재하지 않는 듯한 쾌적함을 유저들이 느낀다면, 그게 바로 너희의 노력이 빛을 발하는 순간일 거야.

자, 그럼 오늘은 여기까지! 다음번엔 더 재밌는 얘기로 돌아올게. 질문 있으면 언제든지 댓글 달아라! 🔥
