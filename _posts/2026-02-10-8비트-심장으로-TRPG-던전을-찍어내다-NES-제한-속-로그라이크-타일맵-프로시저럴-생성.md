---
layout: post
title: "8비트 심장으로 TRPG 던전을 찍어내다: NES 제한 속 '로그라이크 타일맵 프로시저럴 생성'과 규칙 인코딩 전략"
categories: tech
---

![8비트 심장으로 TRPG 던전을 찍어내다: NES 제한 속 '로그라이크 타일맵 프로시저럴 생성'과 규칙 인코딩 전략](https://image.pollinations.ai/prompt/A+pixel+art+dungeon+generator+interface+on+an+old+CRT+monitor%2C+displaying+an+intricate%2C+procedurally+generated+roguelike+dungeon+map+with+distinct+rooms+and+corridors.+The+style+is+reminiscent+of+8-bit+NES+games%2C+with+limited+color+palette+and+blocky+sprites.+On+the+screen%2C+some+abstract+symbols+representing+TRPG+rules+are+overlaid+on+the+map%2C+hinting+at+intelligent+design+despite+procedural+chaos.+A+quirky%2C+mad+scientist-esque+game+developer+with+disheveled+hair+and+safety+goggles+is+intensely+looking+at+the+screen%2C+a+half-eaten+pizza+and+energy+drink+nearby.+The+atmosphere+is+nostalgic+yet+high-tech+in+its+own+retro+way.?width=800&height=450&nologo=true&seed=3046)

> **AI Image Prompt:** A pixel art dungeon generator interface on an old CRT monitor, displaying an intricate, procedurally generated roguelike dungeon map with distinct rooms and corridors. The style is reminiscent of 8-bit NES games, with limited color palette and blocky sprites. On the screen, some abstract symbols representing TRPG rules are overlaid on the map, hinting at intelligent design despite procedural chaos. A quirky, mad scientist-esque game developer with disheveled hair and safety goggles is intensely looking at the screen, a half-eaten pizza and energy drink nearby. The atmosphere is nostalgic yet high-tech in its own retro way.

자, 여어어러분! 오늘은 제가 사랑하는 고대 유물, 닌텐도 NES의 똥꼬쇼에 도전할 시간입니다! 무려 2KB의 램과 1.79MHz의 CPU? 그건 컴퓨터가 아니라 '계산기' 아닌가요? 하지만 우린 괴짜 천재니까, 이 놈의 허약한 심장으로 무한히 변형되는 TRPG 스타일의 로그라이크 던전을 찍어낼 겁니다. “불가능하다”는 말은 “아직 해보지 않았다”는 말과 동의어죠, 안 그런가요?

### [핵심 딜레마] NES의 기억상실증과 TRPG 마스터의 완고함

NES는 고사하고 폰 노이만 아키텍처의 기본 상식조차 비웃는 듯한 자원 제약을 가집니다. 특히 램 2KB는 현대의 'Hello World' 프로그램도 저장하기 버거운 수준이죠. 여기에 TRPG 마스터님들의 "보스방은 절대 시작 지점에서 3칸 안에 두면 안 돼!" 혹은 "함정 방 옆엔 꼭 보물 방이 있어야 하는 법이지!" 같은 완고한 규칙들을 인코딩해야 합니다. 이 미친 조합을 어떻게 이겨낼까요?

정답은 **'타일맵 중심의 압축된 룸 메타데이터 관리'**와 **'트리거 기반의 규칙 적용'**입니다. 전체 던전의 타일 데이터를 램에 다 올리는 건 꿈도 못 꾸고, PPU(Picture Processing Unit)의 VRAM에 현재 화면에 필요한 1KB 남짓한 타일 데이터만 올리고 스크롤링으로 커버해야 합니다. 던전의 구조는 룸(Room) 단위로 나누고, 각 룸의 핵심 정보(위치, 크기, 타입, 연결)만 초압축해서 관리하는 거죠.

### [원리 파고들기] 룸 기반 생성과 TRPG 규칙 주입

우리가 만들 던전은 일종의 '메타 던전'입니다. 전체 타일 지도가 아니라, 룸들의 추상적인 배치와 연결만 램에 저장합니다. 각 룸은 미리 정의된 타일셋 템플릿을 가지고 있어, 화면에 보일 때 실시간으로 타일로 변환됩니다.

**1. 룸 데이터 구조 (초압축 ver.)**

```pseudo
STRUCT Room
    BYTE x, y        // 맵 그리드 상의 룸 좌상단 좌표 (8비트, 0-255)
    BYTE width, height // 룸 크기 (8비트, 1-15타일 등) - NES 타일맵 크기 고려
    BYTE type        // 룸 타입: 시작(0x0), 일반(0x1), 보물(0x2), 함정(0x3), 보스(0x4), 복도(0xF)
    BYTE connections // 연결된 룸 ID 비트마스크 (0bNESW: 북동남서)
    BYTE flags       // 추가 플래그: 방문 여부, 특수 아이템 유무 등
END STRUCT
```

이렇게 하면 하나의 룸이 고작 5~6바이트면 표현 가능합니다! 2KB 램에 넉넉잡아 200개의 룸까지는 관리할 수 있겠죠. NES 던전으로는 충분히 거대한 규모입니다.

**2. TRPG 규칙 인코딩과 적용: '의사결정 주사위' 굴리기**

TRPG 규칙들은 던전 생성 과정의 특정 '트리거' 지점에서 개입하여 알고리즘의 다음 행동을 결정하는 역할을 합니다.

*   **룸 타입 할당 규칙**:
    *   `규칙1: "시작 룸은 항상 맵 중앙 부근에 하나만 존재한다."`
    *   `규칙2: "보스 룸은 던전의 가장 깊은 곳, 시작 룸에서 가장 멀리 떨어진 곳에 배치한다."`
    *   `규칙3: "던전의 전체 룸 중 최소 N%는 보물 룸이어야 하며, 이들은 메인 경로에서 살짝 벗어난 곳에 위치할 확률이 높다."`
    *   `규칙4: "함정 룸은 보물 룸으로 향하는 복도나 출구가 하나뿐인 방에 배치될 확률이 80% 증가한다."`

*   **연결 규칙**:
    *   `규칙5: "보스 룸은 최소 2개 이상의 일반 룸과 연결되어야 하며, 직접적으로 시작 룸과 연결될 수 없다."`
    *   `규칙6: "막다른 골목 룸은 함정 룸이 되거나, 낮은 확률로 히든 보물 룸이 될 수 있다."`

이런 규칙들은 다음과 같은 알고리즘 흐름에 녹아들어갑니다.

### [알고리즘 로직] 8비트 던전 마스터

```pseudo
FUNCTION Generate8BitTRPGDungeon(maxRooms, seed)
    SET RandomSeed = seed
    CREATE RoomList AS EMPTY_ARRAY
    CREATE OccupiedGrid AS BITMAP_ARRAY (e.g., 32x32 = 128 bytes for room placement grid)

    // PHASE 1: 룸 배치 & 타입 할당
    roomCount = 0

    // 규칙1 적용: 시작 룸 생성
    startRoom = CreateRoom(CENTER_X, CENTER_Y, MIN_ROOM_SIZE, MAX_ROOM_SIZE, ROOM_TYPE_START)
    AddRoom(RoomList, startRoom)
    MarkOccupied(OccupiedGrid, startRoom)
    roomCount++

    WHILE roomCount < maxRooms
        // 기존 룸 중 하나를 선택하여 새로운 룸을 확장
        parentRoom = SelectRandomRoom(RoomList)
        newRoomPos = FindEmptyAdjacentSpace(OccupiedGrid, parentRoom, MIN_ROOM_SIZE, MAX_ROOM_SIZE)

        IF newRoomPos IS NOT NULL THEN
            newRoomType = DetermineRoomType(roomCount, maxRooms, parentRoom) // 규칙 2, 3, 4 등 복합 적용
            newRoom = CreateRoom(newRoomPos.x, newRoomPos.y, MIN_ROOM_SIZE, MAX_ROOM_SIZE, newRoomType)
            AddRoom(RoomList, newRoom)
            MarkOccupied(OccupiedGrid, newRoom)
            roomCount++
        END IF
        // 무한 루프 방지, 일정 시도 후 종료
        IF (Failed to place room N times) BREAK
    END WHILE

    // PHASE 2: 룸 연결 (Minimal Spanning Tree + 추가 연결)
    // 룸들을 노드로 하는 그래프를 구성. 거리 기반으로 에지 가중치 부여
    roomGraph = BuildRoomGraph(RoomList)
    mainPath = FindMinimumSpanningTree(roomGraph) // 던전의 기본 골격

    FOREACH edge IN mainPath
        ConnectRooms(edge.roomA, edge.roomB) // 양방향 연결 정보 업데이트 (connections 비트마스크)
    END FOREACH

    // 규칙5, 6 등 적용: 추가 연결 및 특수 복도 생성
    FOREACH room IN RoomList
        IF room.type == ROOM_TYPE_BOSS THEN
            // 규칙5: 보스룸 연결 검사 및 보강
            IF NOT HasSufficientConnections(room, 2) OR IsConnectedTo(room, startRoom) THEN
                AddExtraConnectionToNormalRoom(room, RoomList)
            END IF
        ELSE IF room.type == ROOM_TYPE_DEAD_END THEN
            // 규칙6: 막다른 길 처리
            IF RandomRoll(100) < 30 THEN // 30% 확률로 함정룸으로 변경
                room.type = ROOM_TYPE_TRAP
            ELSE IF RandomRoll(100) < 10 THEN // 10% 확률로 히든 보물룸
                room.type = ROOM_TYPE_TREASURE
                AddHiddenPassageTo(room)
            END IF
        END IF
        // 규칙4: 함정룸과 보물룸 연결 검사 및 복도 생성
        IF room.type == ROOM_TYPE_TRAP AND NOT IsConnectedTo(room, ROOM_TYPE_TREASURE) AND RandomRoll(100) < 80 THEN
            ConnectRoomToClosestOfType(room, ROOM_TYPE_TREASURE)
        END IF
    END FOREACH

    // PHASE 3: 실시간 타일맵 렌더링 (NES PPU 로직)
    // 이 부분은 실제 던전 데이터를 램에 올리는 것이 아니라, 화면 스크롤 시
    // 카메라 위치에 따라 해당 룸들의 타일 데이터만 PPU VRAM에 실시간으로 올리는 로직이 필요.
    // 각 룸 타입에 맞는 미리 정의된 타일셋 템플릿 사용.
    // 복도 타일은 룸 연결 정보에 따라 벽을 뚫고 길을 만듦.

    RETURN RoomList // 생성된 룸 메타데이터
END FUNCTION

FUNCTION DetermineRoomType(currentRoomCount, maxRooms, parentRoom)
    // 여기서 TRPG 규칙들을 기반으로 룸 타입을 동적으로 결정
    // 예시:
    IF currentRoomCount == maxRooms - 1 THEN // 마지막 룸은 보스 룸 (규칙2)
        RETURN ROOM_TYPE_BOSS
    END IF
    IF distance(parentRoom, startRoom) > maxRooms / 3 AND RandomRoll(100) < 20 THEN // 어느 정도 깊이가 되면 보물 룸 확률 증가 (규칙3)
        RETURN ROOM_TYPE_TREASURE
    END IF
    IF IsDeadEndCandidate(parentRoom) AND RandomRoll(100) < 50 THEN // 막다른 골목이 될 가능성이 높은 방은 함정 룸 (규칙4)
        RETURN ROOM_TYPE_TRAP
    END IF
    RETURN ROOM_TYPE_NORMAL // 기본값
END FUNCTION
```

### [괴짜 개발자의 팁] 메모리와 유머는 비례한다!

자, 보셨죠? NES의 한정된 자원 속에서도 우리는 TRPG 마스터의 변태적인 요구사항을 충족시키면서 '무한한' 던전을 만들어낼 수 있습니다. 물론 실제 NES 하드웨어에 이 코드를 돌리려면 어셈블리어의 마법과 비트 연산의 오케스트라가 필요하겠지만, 개념은 이겁니다!

핵심은 **'필요할 때만 생성하고, 더 이상 필요 없을 땐 과감히 버리는'** 자세입니다. NES 램은 사랑스러운 아기자기한 쓰레기통이 아니라, 정교하게 관리되는 극소형 금고여야 합니다. 그리고 TRPG 규칙이요? 그건 우리 알고리즘에게 스파이시한 양념을 쳐주는 역할을 할 뿐입니다. 마스터님들, 미안하지만 당신의 주사위는 이제 제 알고리즘이 굴립니다. 걱정 마세요, 가끔 버그도 던져주니까요. 그게 진짜 TRPG의 묘미 아니겠습니까? (쿨럭)

결론적으로, 제한은 창의성의 어머니입니다. 특히 8비트 콘솔 개발은 마치 붓 대신 몽당연필로 모나리자를 그리는 것과 같습니다. 하지만 결과물을 보면, 그 어떤 현대 게임보다 강렬한 '영혼'이 느껴지죠. 자, 이제 이 던전 생성기로 역대급 8비트 로그라이크를 만들러 갑시다! 코드 컴파일! (삑- 삑- 삑- 옛날 게임보이 시작음 같은 소리)
