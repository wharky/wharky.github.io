---
layout: post
title: "픽셀에 생명을 불어넣는 수학: GLSL & DOTS로 렌더링 한계를 돌파하다"
categories: tech
---

### ⚠️ Image Generation Failed
```text
Prompt: Abstract visualization of complex data structures flowing into a luminous, mathematically generated shader effect, with glowing lines and points representing data, rendered in a cinematic style with deep shadows and volumetric light, concept art, digital painting, ultra detailed, vibrant colors, reflecting the synergy of CPU data-oriented processing and GPU shader math.
```

안녕하세요, 동료 개발자 여러분! 오늘도 커피 한 잔 옆에 두고, 머릿속을 스쳐 가는 깊은 기술 이야기로 찾아온 실력 있는 시니어 게임 개발자이자 테크 블로거, 블로그 주인장입니다. 요즘처럼 고성능 하드웨어와 화려한 그래픽이 당연시되는 시대에, 게임 개발은 끊임없이 '어떻게 더 멋지고, 더 빠르고, 더 효율적으로 만들 것인가?'를 고민하게 만듭니다. 오늘 우리가 파헤칠 주제는 이 질문의 핵심 중 하나인 **'Shader Math & GLSL'**과, 언뜻 보기에 GPU와는 거리가 멀어 보이지만 깊이 있게 연결되어 있는 **'Data-Oriented Technology Stack (DOTS)'**의 결합입니다.

두 키워드가 왠지 억지스럽다고요? 에이, 그럼 저를 과소평가하시는 겁니다! 저는 이 두 녀석이 사실은 같은 DNA를 공유하고 있다고 생각합니다. 바로 '데이터를 중심으로 한 극한의 효율 추구'라는 철학이죠. 자, 그럼 이 두 키워드가 어떻게 만나 엄청난 시너지를 낼 수 있는지, 제 경험과 함께 깊이 있는 이야기를 시작해 볼까요?

### Part 1: GPU의 심장을 뛰게 하는 언어, Shader Math & GLSL

우리가 만드는 게임 속 세상은 결국 수많은 '픽셀'들의 향연입니다. 이 픽셀 하나하나에 생명을 불어넣는 마법이 바로 셰이더(Shader)죠. 그리고 그 마법의 주문은 다름 아닌 '수학'입니다. 기본 텍스처와 간단한 조명만으로는 더 이상 게이머들을 감동시키기 어렵습니다. 복잡한 표면 재질, 유려한 파도, 시시각각 변하는 날씨 효과, 혹은 수천 개의 개체가 각기 다른 개성을 뽐내야 할 때, CPU의 계산 능력을 빌려 픽셀 하나하나를 제어하는 건 불가능에 가깝습니다.

**[문제점]** CPU가 모든 픽셀의 색상과 속성을 계산하고 GPU로 전송한다면, 병목 현상으로 인해 프레임이 폭락할 겁니다. 또한, 복잡한 시각 효과를 정적인 에셋만으로 구현하는 것은 한계가 있습니다.

**[해결책]** GPU의 병렬 처리 능력을 최대한 활용해야 합니다. GLSL(OpenGL Shading Language)은 바로 그 강력한 도구이며, 그 핵심은 **셰이더 수학(Shader Math)**입니다. 셰이더는 GPU 내에서 독립적으로 실행되는 작은 프로그램이며, 주로 정점(Vertex)과 픽셀(Fragment)에 대한 연산을 담당합니다. 셰이더는 '주어진 데이터를 가지고 어떻게 픽셀을 그릴 것인가'라는 순수한 함수(Pure Function)의 관점에서 작동합니다.

#### 1. 벡터 수학의 미학: 빛과 그림자, 그리고 공간의 이해

셰이더 코드를 작성할 때 가장 많이 사용되는 것이 벡터(Vector)와 행렬(Matrix)입니다. 빛의 방향, 표면의 법선(Normal), 카메라의 위치 등 모든 것이 벡터로 표현됩니다.

*   **내적(Dot Product):** 빛의 방향과 표면 법선 벡터의 내적은 빛이 표면에 얼마나 수직으로 비추는지를 알려주며, 이는 확산광(Diffuse Light) 계산의 핵심입니다.
    ```glsl
    // 의사코드: 프래그먼트 셰이더 내에서 확산광 계산
    vec3 lightDir = normalize(lightPosition - fragmentPosition); // 광원 방향
    vec3 normal = normalize(fragmentNormal); // 표면 법선
    float diffuse = max(dot(normal, lightDir), 0.0); // 내적을 이용해 확산광 계산
    vec3 finalColor = objectColor * lightColor * diffuse;
    ```
    이 간단한 내적 하나로 우리는 3D 객체가 빛을 받는 모습을 표현할 수 있습니다. 픽셀 하나하나가 이 연산을 병렬로 수행하니, 얼마나 효율적인가요?
*   **외적(Cross Product):** 두 벡터에 모두 수직인 새로운 벡터를 찾아, 주로 법선 벡터를 계산하거나 회전축을 결정하는 데 사용됩니다.
*   **행렬(Matrix):** 객체의 이동, 회전, 크기 조절(Transformations)을 표현하며, 로컬 공간에서 월드 공간, 뷰 공간, 그리고 최종적으로 화면에 투영되는 클립 공간으로 정점의 위치를 변환하는 데 필수적입니다. 이 모든 변환이 각 정점에서 GPU에 의해 병렬로 처리됩니다.

제 경험상, 셰이더 디버깅의 9할은 벡터와 행렬 연산의 오류에서 나옵니다. 어떤 공간에서 어떤 좌표를 쓰고 있는지, 행렬 곱셈 순서가 맞는지 등을 꼼꼼히 따지는 습관이 중요합니다.

#### 2. 절차적 생성(Procedural Generation)과 SDFs: 무한한 세상을 효율적으로

**[문제점]** 복잡한 유기적 형태, 미세한 디테일, 또는 수많은 반복적인 패턴을 모두 텍스처로 만들거나 3D 모델로 제작하는 것은 메모리와 리소스 낭비가 심하고 유연성이 떨어집니다.

**[해결책]** 수학 공식을 이용해 픽셀 데이터를 실시간으로 생성합니다. 노이즈 함수(Noise Function, Perlin, Simplex 등)나 부호화된 거리 함수(Signed Distance Functions, SDFs)는 이 분야의 핵심 도구입니다.

*   **노이즈 함수:** 자연스러운 구름, 대리석 무늬, 울퉁불퉁한 지형 등을 적은 연산으로 만들어낼 수 있습니다.
    ```glsl
    // 의사코드: Simplex Noise를 이용한 간단한 절차적 텍스처
    float noiseValue = snoise(fragmentUV * 10.0); // UV 좌표에 따라 노이즈 생성
    vec3 color = mix(vec3(0.1, 0.4, 0.7), vec3(0.9, 0.8, 0.6), noiseValue); // 노이즈 값으로 색상 보간
    ```
*   **SDFs:** 객체의 표면으로부터 가장 가까운 거리를 부호 있는 값으로 반환하는 함수입니다. 이를 이용하면 원, 박스 같은 기본 도형은 물론, 이들을 불리언(Boolean) 연산(Union, Intersect, Subtract)으로 조합하여 극도로 복잡한 모양을 만들어낼 수 있습니다. 심지어 레이마칭(Ray Marching)과 같은 고급 렌더링 기법의 근간이 되기도 합니다.

    ```glsl
    // 의사코드: 구와 박스의 SDF
    float sdSphere(vec3 p, float s) { return length(p) - s; }
    float sdBox(vec3 p, vec3 b) { return length(max(abs(p) - b, 0.0)); }

    // SDF 조합 (Union)
    float opUnion(float d1, float d2) { return min(d1, d2); }
    // SDF 조합 (Subtraction)
    float opSubtract(float d1, float d2) { return max(-d1, d2); }

    // 프래그먼트 셰이더 내에서:
    // float dist = opUnion(sdSphere(p, 1.0), sdBox(p, vec3(0.8)));
    // 이 dist 값을 이용해 렌더링 결정
    ```
    SDFs는 정말 놀라운 기술입니다. 수년 전, 처음 SDF를 이용해 복잡한 유기체 형태를 수학 공식 몇 줄로 만들어내는 것을 보고, "아, 이게 바로 GPU가 꿈꾸는 세상이구나!" 하고 무릎을 쳤던 기억이 생생합니다. 이는 데이터 중심적으로 GPU의 연산 능력을 극대화하는 대표적인 예시입니다.

### Part 2: 효율의 끝판왕, DOTS 철학과의 만남

자, 셰이더 수학으로 GPU를 불태우는 방법을 배웠습니다. 이제 수만, 수십만 개의 개체들이 복잡하게 상호작용하며 시뮬레이션되는 게임 월드를 상상해 봅시다. DOTS가 없었다면 꿈도 꾸기 어려운 일입니다. 그런데 이 DOTS가 GPU 렌더링, 특히 셰이더와 무슨 관련이 있을까요?

**[문제점]** 전통적인 GameObject/MonoBehaviour 패턴은 CPU 캐시 미스(Cache Miss), 불필요한 데이터 탐색, 그리고 객체 지향적 상속 구조에서 오는 오버헤드 때문에 수많은 개체를 효율적으로 처리하기 어렵습니다. 아무리 셰이더가 빨라도, GPU에 보낼 데이터를 CPU가 제때 준비하지 못하면 병목이 생깁니다.

**[해결책]** DOTS(Data-Oriented Technology Stack)는 데이터 지향(Data-Oriented)적인 사고방식을 통해 CPU의 성능 한계를 돌파합니다. ECS(Entity Component System)는 데이터를 컴포넌트로 분리하고, 엔티티를 통해 이들을 조합합니다. 시스템(System)은 이 컴포넌트 데이터에 대한 순수한 함수처럼 동작하며, Job System과 Burst Compiler는 이를 극한으로 병렬화하고 최적화합니다.

#### 1. 철학적 연결: '순수 함수'와 '데이터 지역성'

셰이더는 입력된 픽셀/정점 데이터에 대해 수학 연산을 수행하는 '순수 함수'입니다. 외부 상태에 의존하지 않고, 오직 자신의 입력값에 따라 출력값을 결정하죠. DOTS의 시스템 역시 특정 컴포넌트 데이터 셋에 대해 독립적으로 작동하는 '순수 함수'에 가깝습니다.

*   **데이터 지역성(Data Locality):** 셰이더는 GPU 캐시를 최대한 활용하여 인접 픽셀 데이터를 효율적으로 처리합니다. DOTS 역시 메모리 상에서 관련 데이터를 한데 모아 CPU 캐시 효율을 극대화합니다. 이 둘은 모두 데이터를 최대한 연속적이고 예측 가능한 형태로 배치하여 처리 속도를 높이는 데 집중합니다.
*   **병렬성(Parallelism):** 셰이더는 수천 개의 코어에서 픽셀 단위로 병렬 연산을 수행합니다. DOTS는 Job System을 통해 CPU 코어 전체를 활용하여 수많은 엔티티의 데이터를 병렬로 처리합니다.

이러한 공통된 철학은 GPU와 CPU 최적화가 사실은 같은 목표를 향해 달려가고 있음을 보여줍니다. 결국 '최대한 적은 데이터를, 최대한 효율적인 방식으로, 최대한 병렬적으로 처리한다'는 것이죠.

#### 2. 실용적 시너지: DOTS가 만드는 데이터, 셰이더가 그리는 현실

진정한 시너지는 DOTS가 수만 개의 엔티티를 효율적으로 시뮬레이션하고 관리하면서, 그 결과로 생성된 데이터를 셰이더가 받아 처리할 때 발생합니다.

*   **대규모 동적 월드의 렌더링:** DOTS는 수천, 수만 개의 캐릭터, 파편, 풀잎, 효과들이 각자 다른 위치, 크기, 색상, 애니메이션 상태를 가질 수 있도록 합니다. 이 모든 동적인 데이터를 DOTS의 효율적인 데이터 파이프라인을 통해 GPU에 전달할 수 있습니다.
*   **인스턴싱(Instancing)과 셰이더:** DOTS는 Unity의 BatchRendererGroup이나 Graphics.DrawMeshInstancedIndirect 등을 통해 수많은 동일 또는 유사 메쉬를 한 번의 드로우 콜(Draw Call)로 렌더링하는 데 최적화되어 있습니다. 여기서 셰이더는 빛을 발합니다.
    *   **예시:** 10,000마리의 새 떼를 시뮬레이션한다고 가정해 봅시다. DOTS는 각 새의 위치, 속도, 날개 짓 주기, 심지어는 고유한 '피로도' 같은 상태를 ECS 컴포넌트로 관리하고 매 프레임 업데이트합니다. 이 데이터는 GPU 버퍼로 넘어갑니다.
    *   GLSL 셰이더는 이 버퍼에서 각 새의 고유 데이터를 읽어들여, 날개 짓 애니메이션을 절차적으로 계산하고(사인/코사인 함수로 날개 각도 계산), 피로도에 따라 깃털의 색깔이나 움직임을 다르게 표현합니다. 이 모든 것이 **하나의 셰이더 프로그램 내에서, 각 인스턴스별로** 효율적인 수학 연산을 통해 이루어집니다. CPU는 단 한 번의 드로우 콜을 던지고, 나머지는 셰이더가 수학적으로 처리하는 것이죠.
    ```glsl
    // 의사코드: 인스턴스별 데이터 접근 및 셰이더 연산 (버텍스 셰이더)
    struct InstanceData {
        vec3 position;
        float wingCycle; // 0.0 ~ 1.0
        vec3 baseColor;
    };
    layout(std140, binding = 0) readonly buffer InstanceBuffer {
        InstanceData instances[];
    };

    void main() {
        InstanceData currentInstance = instances[gl_InstanceID];
        // 인스턴스 고유의 위치 적용
        vec4 worldPos = modelMatrix * vec4(a_position + currentInstance.position, 1.0);
        
        // 날개 짓 애니메이션 (절차적으로 계산)
        float wingAngle = sin(currentInstance.wingCycle * 2.0 * PI) * 0.5;
        // 특정 정점 (날개 부분)에만 회전 적용
        // worldPos = rotateWing(worldPos, wingAngle); // 날개 회전 함수
        
        gl_Position = projectionMatrix * viewMatrix * worldPos;
        v_color = currentInstance.baseColor; // 인스턴스 고유 색상
    }
    ```
    이처럼 DOTS가 효율적으로 '어떤 데이터를 어디에' 둘 것인가를 결정하면, 셰이더는 '그 데이터를 가지고 무엇을 할 것인가'를 수학적으로 정교하게 구현합니다. 둘 중 하나라도 최적화되지 않으면, 전체 시스템은 병목에 걸리게 됩니다.

### 결론: 데이터 지향적 사고로 GPU와 CPU의 시너지를 극대화하라

오늘 우리는 'Shader Math & GLSL'이 어떻게 픽셀에 생명을 불어넣고 복잡한 시각 효과를 효율적으로 구현하는지, 그리고 'DOTS'의 데이터 지향적 철학이 어떻게 GPU 렌더링, 특히 셰이더의 진정한 잠재력을 끌어내는 촉매제가 되는지를 살펴보았습니다.

현업 개발자로서, 저는 여러분께 당부하고 싶습니다. 단순히 그래픽 API를 사용하는 것을 넘어, **셰이더 수학을 깊이 이해하는 것은 선택이 아닌 필수**가 되고 있습니다. 이는 GPU의 가장 근본적인 언어를 이해하는 것이며, 여러분의 게임이 시각적으로 독보적이고 성능적으로 우수해지는 지름길입니다.

또한, CPU와 GPU는 더 이상 독립적인 존재가 아닙니다. DOTS와 같은 기술 스택은 CPU가 대규모 데이터를 얼마나 효율적으로 관리하고 GPU로 전달하는지를 보여줍니다. CPU의 데이터 흐름을 최적화하는 것은 GPU 렌더링 성능에 직접적인 영향을 미치며, 그 반대도 마찬가지입니다. 두 영역 모두에서 '데이터를 효율적으로 다루는' 데이터 지향적 사고방식을 갖춘 개발자가 바로 미래의 게임 개발을 이끌어갈 핵심 인재가 될 것입니다.

그러니 오늘부터라도 GLSL 셰이더 코드를 가지고 놀아보고, 벡터와 행렬 연산을 손으로 풀어보며, DOTS가 어떻게 데이터를 구조화하는지 탐구해보세요. 여러분의 코드가 픽셀 하나하나에, 그리고 수많은 엔티티 하나하나에 살아 숨 쉬는 마법을 경험하게 될 것입니다.

다음 포스팅에서는 또 다른 흥미로운 주제로 찾아오겠습니다. 그때까지, Keep Coding & Stay Awesome!
