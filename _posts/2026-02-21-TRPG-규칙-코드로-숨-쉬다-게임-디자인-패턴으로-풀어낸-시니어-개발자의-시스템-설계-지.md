---
layout: post
title: "TRPG 규칙, 코드로 숨 쉬다: 게임 디자인 패턴으로 풀어낸 시니어 개발자의 시스템 설계 지혜"
categories: tech
---

### ⚠️ Image Generation Failed
```text
Prompt: Abstract cinematic lighting, a complex holographic projection of a D20 dice integrated with circuit board patterns, glowing lines representing data flow, mystical TRPG elements like a scroll or a potion bottle subtly integrated into the tech aesthetic, deep blues and purples with bright neon accents, volumetric light, highly detailed, octane render.
```

안녕하세요, 동료 개발자 여러분! 오늘 커피 한 잔 하면서 나눌 이야기는 단순한 코드 한 조각이 아닙니다. 바로 **'TRPG Rule Systems implemented in Code'**와 **'Game Design Patterns'**의 흥미로운 교차점입니다. 이 두 키워드가 만났을 때 어떤 마법이 일어나는지, 그리고 그것이 여러분의 게임 개발에 어떤 실질적인 영감을 줄 수 있는지 깊이 파고들어 보려 합니다. 언뜻 보면 주사위 굴림과 몬스터 도감 같은 아날로그적인 TRPG 규칙이 어떻게 최신 게임 디자인 패턴과 시너지를 낼 수 있을까 싶으시죠? 저 역시 처음에는 '코드에 덕지덕지 붙이는 기능'쯤으로 생각했던 시절이 있었습니다. 하지만 시스템의 복잡도가 증가하면서, 이 두 가지가 만나면 얼마나 견고하고 유연한 아키텍처를 만들 수 있는지 깨달았죠.

### 문제: 엉망진창 TRPG 시스템, 스파게티 코드를 부르다!

제가 처음 TRPG 규칙을 디지털화하던 시절을 회상해보면, 정말이지 '개발자 고행길' 그 자체였습니다. 플레이어가 주사위를 굴려 스킬 체크를 하고, 몬스터와 전투하며, 상태 이상에 걸리고, 마법을 사용하는 이 모든 과정을 코드로 구현하려니 끝없는 `if-else`문과 하드코딩된 로직의 늪에 빠지기 일쑤였죠.

*   **문제 1: 캐릭터 스탯 및 능력 관리의 경직성.** 새로운 종족이나 직업을 추가할 때마다 스탯 계산 로직을 갈아엎어야 했습니다.
*   **문제 2: 스킬 체크와 액션 처리의 비확장성.** "민첩 체크로 함정 피하기"와 "힘 체크로 문 부수기"가 다른 코드 블록에서 제각각 구현되어, 새로운 체크 방식을 추가하기가 어려웠습니다.
*   **문제 3: 전투 시스템의 복잡성과 예측 불가능성.** 턴 순서, 상태 이상, 버프/디버프 등 복잡한 상호작용이 뒤섞여 버그 추적이 지옥 같았습니다.

이런 상황에서 코드는 점점 스파게티처럼 얽히고설켰고, 작은 규칙 변경 하나가 시스템 전체를 흔드는 지뢰밭이 되어버렸습니다. "아, 이러다간 게임 개발 전에 내가 먼저 멘붕 오겠다!" 싶은 순간, 저는 '디자인 패턴'이라는 구원투수를 만나게 됩니다.

### 해결책: 게임 디자인 패턴, TRPG 규칙에 숨결을 불어넣다

TRPG 규칙을 코드로 구현하는 것은 결국 **유연하고 확장 가능한 시뮬레이션 시스템**을 만드는 과정과 같습니다. 그리고 여기에 게임 디자인 패턴이 완벽한 해답을 제공합니다. 패턴은 복잡한 문제를 해결하기 위한 검증된 청사진이자, 개발자들이 공통의 언어로 소통할 수 있는 훌륭한 도구니까요.

#### 1. 캐릭터 시스템: 컴포넌트 패턴 (Component Pattern)으로 유연성 확보

TRPG의 캐릭터는 단순히 스탯 덩어리가 아닙니다. 마법사일 수도, 전사일 수도, 도적일 수도 있죠. 각자의 스킬셋, 장비, 특성이 다릅니다. 이 문제를 해결하기 위해 저는 **컴포넌트 패턴**을 적극적으로 도입했습니다. 특히 게임에서는 ECS(Entity-Component-System) 아키텍처가 매우 강력한데요, TRPG 규칙 시스템에도 이 원칙을 적용하면 좋습니다.

**기존 문제:** `Warrior` 클래스와 `Mage` 클래스가 각각 `Attack()` 메서드를 구현하고, 스탯 관리도 개별적으로 처리. 새로운 직업을 추가하면 상속 계층이 복잡해지고 중복 코드가 발생.

**해결책:** `Character`를 '엔티티'로 정의하고, 기능들을 '컴포넌트'로 분리했습니다. `StatsComponent`, `InventoryComponent`, `SkillComponent`, `CombatComponent` 등을 필요한 대로 붙여 넣는 방식이죠.

```pseudo
// IComponent 인터페이스 (모든 컴포넌트의 기본)
interface IComponent {
    // optional: void SetOwner(Entity owner);
}

// Entity 클래스 (캐릭터, 몬스터 등)
class Entity {
    private Dictionary<Type, IComponent> components = new Dictionary<Type, IComponent>();

    public void AddComponent<T>(T component) where T : IComponent {
        components[typeof(T)] = component;
        // component.SetOwner(this);
    }

    public T GetComponent<T>() where T : IComponent {
        if (components.TryGetValue(typeof(T), out var component)) {
            return (T)component;
        }
        return default(T); // 또는 null
    }

    public void RemoveComponent<T>() where T : IComponent {
        components.Remove(typeof(T));
    }
}

// StatsComponent 예시
class StatsComponent : IComponent {
    public Dictionary<StatType, int> BaseStats { get; private set; }
    public Dictionary<StatType, int> Modifiers { get; private set; } // 버프/디버프

    public StatsComponent(Dictionary<StatType, int> baseStats) {
        BaseStats = baseStats;
        Modifiers = new Dictionary<StatType, int>();
    }

    public int GetEffectiveStat(StatType type) {
        return BaseStats.GetValueOrDefault(type, 0) + Modifiers.GetValueOrDefault(type, 0);
    }

    // Modifier 적용/제거 메서드 추가
}

// 사용 예시
Entity player = new Entity();
player.AddComponent(new StatsComponent(new Dictionary<StatType, int> {
    { StatType.Strength, 10 },
    { StatType.Dexterity, 12 }
}));
player.AddComponent(new InventoryComponent());
player.AddComponent(new SkillComponent());

// 민첩 스탯 얻기
int dex = player.GetComponent<StatsComponent>().GetEffectiveStat(StatType.Dexterity);
```
이렇게 함으로써, 플레이어 캐릭터든 몬스터든, 심지어는 상호작용 가능한 환경 오브젝트까지 동일한 `Entity` 기반 위에서 유연하게 구축할 수 있었습니다. '전투만 하는 몬스터'는 `CombatComponent`만, '대화만 가능한 NPC'는 `DialogueComponent`만 가질 수 있게 된 거죠. 진정한 '조립식 캐릭터'가 탄생한 순간이었습니다.

#### 2. 스킬 체크 및 액션 처리: 커맨드 패턴 (Command Pattern)과 스트래티지 패턴 (Strategy Pattern)

TRPG에서 플레이어는 "공격", "방어", "스킬 사용", "아이템 사용" 등 수많은 액션을 수행합니다. 이 액션들은 단순히 실행되는 것을 넘어, 취소되거나, 지연되거나, 큐에 쌓이거나, 심지어는 재실행되어야 할 수도 있습니다. 여기에 **커맨드 패턴**이 기막히게 들어맞습니다.

**기존 문제:** `Player.Attack()`, `Player.UseSkill(skillId)`, `Player.UseItem(itemId)` 등 액션마다 호출 메서드가 다르고, 입력 처리와 액션 실행이 강하게 결합되어 있었습니다.

**해결책:** 모든 액션을 `ICommand` 인터페이스를 구현하는 객체로 만들었습니다. 이제 입력 처리기는 단순히 `ICommand` 객체를 생성하여 실행 큐에 넣거나 즉시 실행하도록 지시할 수 있습니다.

```pseudo
// ICommand 인터페이스
interface ICommand {
    void Execute();
    void Undo(); // 필요에 따라 추가
}

// AttackCommand 예시
class AttackCommand : ICommand {
    private Entity attacker;
    private Entity target;
    private int damage; // 계산 로직은 실행 시점 또는 생성 시점에

    public AttackCommand(Entity attacker, Entity target) {
        this.attacker = attacker;
        this.target = target;
    }

    public void Execute() {
        // 실제 공격 로직: 스탯, 무기, 방어력 등을 기반으로 데미지 계산
        var attackerStats = attacker.GetComponent<StatsComponent>();
        var targetStats = target.GetComponent<StatsComponent>();
        
        damage = CalculateDamage(attackerStats, targetStats); // 데미지 계산 로직은 외부 Strategy 또는 내부
        target.GetComponent<HealthComponent>().TakeDamage(damage);
        Console.WriteLine($"{attacker.Name} attacks {target.Name} for {damage} damage.");
    }

    public void Undo() { /* 데미지를 되돌리는 로직 (선택 사항) */ }
}

// CommandManager 예시
class CommandManager {
    private Queue<ICommand> commandQueue = new Queue<ICommand>();

    public void AddCommand(ICommand command) {
        commandQueue.Enqueue(command);
    }

    public void ProcessCommands() {
        while (commandQueue.Count > 0) {
            commandQueue.Dequeue().Execute();
        }
    }
}
```

여기에 스킬 체크 같은 '판정 방식'은 **스트래티지 패턴**으로 분리하면 금상첨화입니다. "D20 굴림으로 성공/실패 판정" 또는 "100분율 굴림으로 성공/실패 판정"처럼요.

```pseudo
// ISkillCheckStrategy 인터페이스
interface ISkillCheckStrategy {
    bool PerformCheck(int skillValue, int difficulty);
}

// D20RollStrategy 예시
class D20RollStrategy : ISkillCheckStrategy {
    public bool PerformCheck(int skillValue, int difficulty) {
        Random rand = new Random(); // 실제로는 시드 관리가 필요
        int roll = rand.Next(1, 21); // D20 굴림
        return (roll + skillValue) >= difficulty;
    }
}

// SkillCheckCommand 예시 (커맨드 패턴과 스트래티지 패턴의 결합)
class SkillCheckCommand : ICommand {
    private Entity performer;
    private ISkillCheckStrategy strategy;
    private StatType skillType;
    private int difficulty;
    public bool IsSuccess { get; private set; }

    public SkillCheckCommand(Entity performer, ISkillCheckStrategy strategy, StatType skillType, int difficulty) {
        this.performer = performer;
        this.strategy = strategy;
        this.skillType = skillType;
        this.difficulty = difficulty;
    }

    public void Execute() {
        int skillValue = performer.GetComponent<StatsComponent>().GetEffectiveStat(skillType);
        IsSuccess = strategy.PerformCheck(skillValue, difficulty);
        Console.WriteLine($"{performer.Name} attempts a {skillType} check (DC {difficulty}). Result: {IsSuccess}");
    }

    public void Undo() { /* ... */ }
}
```
이제 새로운 스킬 체크 방식이 필요하면 `ISkillCheckStrategy`를 구현하는 새 클래스만 만들면 됩니다. 로직 변경 없이 확장성을 확보하게 된 거죠.

#### 3. 전투 시스템: 상태 패턴 (State Pattern)으로 질서 부여

TRPG 전투는 턴 기반이든 실시간이든, 다양한 '상태'를 가집니다: 전투 시작, 플레이어 턴, 몬스터 턴, 턴 종료, 전투 종료 등. 이 상태들의 전환과 각 상태에서 가능한 액션 관리는 매우 복잡합니다. 여기에 **상태 패턴**을 적용하면 시스템에 질서와 명확성을 부여할 수 있습니다.

**기존 문제:** `CombatManager` 클래스 안에 거대한 `switch` 문으로 현재 전투 단계를 구분하고, 각 단계마다 수많은 조건문으로 다음 상태를 결정. 특정 단계에서만 가능한 액션을 다른 곳에서 호출하면 버그 발생.

**해결책:** `ICombatState` 인터페이스를 정의하고, 각 전투 단계를 이 인터페이스를 구현하는 클래스로 분리했습니다. `CombatManager`는 현재 상태 객체에 대한 참조만 가지고, 모든 처리를 현재 상태 객체에 위임합니다.

```pseudo
// ICombatState 인터페이스
interface ICombatState {
    void EnterState(CombatManager combatManager);
    void ExitState(CombatManager combatManager);
    void HandleInput(CombatManager combatManager, Input input);
    void Update(CombatManager combatManager, float deltaTime);
}

// PlayerTurnState 예시
class PlayerTurnState : ICombatState {
    public void EnterState(CombatManager combatManager) {
        Console.WriteLine("Player's Turn Begins!");
        // UI 업데이트, 플레이어 액션 대기 등
    }

    public void ExitState(CombatManager combatManager) {
        Console.WriteLine("Player's Turn Ends!");
    }

    public void HandleInput(CombatManager combatManager, Input input) {
        if (input.Type == InputType.Attack) {
            // 공격 커맨드 생성 및 실행
            combatManager.ExecutePlayerAction(new AttackCommand(combatManager.GetCurrentPlayer(), input.Target));
            combatManager.ChangeState(new EnemyTurnState()); // 다음 상태로 전환
        }
        // 다른 플레이어 액션 처리
    }

    public void Update(CombatManager combatManager, float deltaTime) {
        // 시간 기반의 턴 진행 로직 (예: 턴 타이머)
    }
}

// CombatManager 예시
class CombatManager {
    private ICombatState currentState;
    private Entity currentPlayer; // 현재 턴을 가진 플레이어/몬스터

    public CombatManager() {
        ChangeState(new SetupState()); // 전투 시작 시 초기 상태 설정
    }

    public void ChangeState(ICombatState newState) {
        currentState?.ExitState(this); // 이전 상태 종료
        currentState = newState;
        currentState.EnterState(this); // 새 상태 진입
    }

    public void HandleInput(Input input) {
        currentState.HandleInput(this, input);
    }

    public void Update(float deltaTime) {
        currentState.Update(this, deltaTime);
    }

    public Entity GetCurrentPlayer() { return currentPlayer; }
    public void ExecutePlayerAction(ICommand command) {
        // 커맨드 실행 로직
        command.Execute();
    }
    // ... 기타 전투 관련 메서드
}
```
각 상태가 자기 역할에만 집중함으로써, 전투 로직은 훨씬 깔끔하고 이해하기 쉬워졌습니다. 새로운 전투 페이즈를 추가하는 것도 이제 새로운 상태 클래스 하나만 만들면 되는 일이고요.

### 시니어 개발자의 의견: 패턴은 도구이지, 목적이 아니다

위에서 설명한 패턴들은 제가 TRPG 규칙 시스템을 코드로 구현하면서 뼈저리게 느꼈던 '문제점'들을 해결해준 강력한 도구들입니다. 특히 복잡한 규칙이 얽혀있는 TRPG의 특성상, 초기 설계 단계부터 확장성과 유연성을 고려하는 것이 매우 중요합니다.

하지만 여러분, 명심하세요. **디자인 패턴은 만능 해결사가 아닙니다.** 그리고 모든 상황에 모든 패턴을 무작정 적용하려 해서는 안 됩니다. 오히려 과도한 패턴 사용은 시스템을 불필요하게 복잡하게 만들 수 있습니다. 중요한 것은 '어떤 문제가 있고', '이 문제를 해결하는 데 어떤 패턴이 가장 적합한가'를 고민하는 지혜입니다.

저의 경험상, TRPG 규칙을 코드로 옮기는 과정은 단순한 개발 작업을 넘어, **규칙 자체에 대한 깊은 이해와 시스템 설계 능력**을 동시에 요구합니다. 우리가 TRPG에서 "왜 이런 규칙이 필요한가?"를 고민하듯이, 코드에서도 "왜 이 패턴을 적용해야 하는가?"를 물어야 합니다.

TRPG는 플레이어의 상상력과 시스템의 견고함이 만나 무한한 이야기를 만들어내는 장르입니다. 이를 코드로 구현한다는 것은, 그 상상력이 활발하게 숨 쉴 수 있도록 단단하면서도 유연한 뼈대를 만들어주는 일이라고 생각합니다. 게임 디자인 패턴은 그 뼈대를 만드는 데 있어 가장 든든한 동반자가 되어줄 것입니다.

다음번에 복잡한 게임 시스템을 설계할 때, TRPG 규칙을 코드로 옮기는 시니어 개발자의 고민과 패턴 활용 사례를 떠올려보시길 바랍니다. 분명 여러분에게 새로운 영감과 실질적인 해결책을 제시해 줄 것이라 확신합니다. 행복한 코딩 되세요!
