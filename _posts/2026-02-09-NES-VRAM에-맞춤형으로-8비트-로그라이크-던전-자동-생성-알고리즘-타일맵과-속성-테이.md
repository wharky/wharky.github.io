---
layout: post
title: "NES VRAM에 맞춤형으로! 8비트 로그라이크 던전 자동 생성 알고리즘: 타일맵과 속성 테이블 최적화 기법"
categories: tech
---

![NES VRAM에 맞춤형으로! 8비트 로그라이크 던전 자동 생성 알고리즘: 타일맵과 속성 테이블 최적화 기법](https://image.pollinations.ai/prompt/A+quirky+genius+game+developer+with+wild%2C+brightly+colored+hair%2C+wearing+oversized+glasses%2C+intensely+coding+on+an+old+CRT+monitor+displaying+pseudo-code.+The+monitor+screen+shows+a+vibrant%2C+top-down+pixel+art+view+of+a+procedurally+generated+NES-style+roguelike+dungeon%2C+complete+with+visible+8x8+tile+grids+and+a+distinct+2x2+attribute+block+overlay.+The+developer%27s+desk+is+cluttered+with+retro+console+parts+%28NES+cartridge%2C+SNES+controller%29%2C+coffee+cups%2C+and+circuit+diagrams+that+seem+to+glow.+The+background+is+a+shadowy+game+development+lab%2C+with+faint+blueprints+on+the+wall.+The+atmosphere+is+a+mix+of+intense+focus%2C+creative+chaos%2C+and+retro+nostalgia%2C+with+a+subtle+magical+glow+emanating+from+the+code.+Art+style%3A+8-bit+pixel+art+refined+with+modern+lighting+and+a+touch+of+vaporwave+aesthetic.?width=800&height=450&nologo=true&seed=581)

> **AI Image Prompt:** A quirky genius game developer with wild, brightly colored hair, wearing oversized glasses, intensely coding on an old CRT monitor displaying pseudo-code. The monitor screen shows a vibrant, top-down pixel art view of a procedurally generated NES-style roguelike dungeon, complete with visible 8x8 tile grids and a distinct 2x2 attribute block overlay. The developer's desk is cluttered with retro console parts (NES cartridge, SNES controller), coffee cups, and circuit diagrams that seem to glow. The background is a shadowy game development lab, with faint blueprints on the wall. The atmosphere is a mix of intense focus, creative chaos, and retro nostalgia, with a subtle magical glow emanating from the code. Art style: 8-bit pixel art refined with modern lighting and a touch of vaporwave aesthetic.

자, 제군들! 어서 와요, 이 정신 나간 천재 개발자의 아지트에 온 걸 환영합니다! 오늘 우리가 다룰 주제는 그 흔한 '레트로 감성'을 넘어선, 진정한 '레트로 개발자의 고뇌'를 파고드는 시간입니다. 요즘 같은 시대에 GPU 메모리가 GB 단위로 놀아나는데, 고작 2KB의 VRAM으로 기적을 만들었던 옛날 개발자들의 발자취를 따라가 볼 겁니다. 맞아요, 바로 NES(패미컴)! 이 작고 귀여운 상자 안에서 어떻게 끝없이 새로운 던전이 펼쳐지는 로그라이크 게임을 만들 수 있었을까요?

저는 오늘 이 무모하고도 매력적인 도전을 여러분과 함께할 겁니다. 바로 "NES VRAM 제약사항을 철저히 준수하는 8비트 로그라이크 던전 자동 생성 알고리즘"이죠. 단순히 픽셀 아트만 레트로가 아니라, *하드웨어의 영혼까지 레트로*하게 만드는 실무적인 접근입니다. "아니, 요즘 누가 저런 걸 개발해?"라고요? 후후, 그게 바로 괴짜 천재 개발자의 로망 아니겠어요?

---

### **Deep Dive: NES VRAM, 그 지독한 매력**

NES의 VRAM은 고작 2KB! 이 작은 공간에 게임 화면을 구성하는 모든 시각 정보가 담겨야 했습니다. 이게 요즘 같으면 텍스처 한 장도 제대로 못 넣을 용량이라고요! 하지만 이 2KB는 기적처럼 쪼개져서 효율적으로 사용되었죠.

1.  **네임테이블 (Nametables)**: 0x2000-0x2FFF. 32x30 타일 (1KB) 두 개가 들어갑니다. 게임 화면 하나가 32x30 타일이니, 총 두 화면 분량의 타일맵 정보가 저장되죠. 스크롤링 게임에서는 이 두 네임테이블을 교대로 사용하며 부드러운 화면 전환을 구현했습니다. 우리 던전의 논리적 크기는 이 32x30 타일을 넘어서면 안 되겠죠? (물론 뱅크 스위칭 같은 고급 기법으로 더 많은 네임테이블을 로드할 수도 있지만, 기본은 이렇다는 겁니다!)
2.  **속성 테이블 (Attribute Tables)**: 0x23C0-0x23FF, 0x27C0-0x27FF. 각 네임테이블 영역 내에 포함됩니다. 여기서부터 머리가 좀 아파지기 시작합니다. 이 속성 테이블은 2x2 타일 블록(16x16 픽셀)마다 배경 팔레트를 지정합니다. 즉, 2x2 타일 블록 하나에 단 4개의 팔레트 중 하나만 선택할 수 있습니다. 각 팔레트는 3가지 색상 + 투명색을 가질 수 있죠 (물론 3가지 색상 중 하나는 백그라운드 컬러라 사실상 3색).
    *   **핵심**: 이 말인즉슨, 인접한 네 개의 타일이 한 덩어리가 되어 같은 4색 팔레트를 공유해야 한다는 겁니다. 만약 한 블록 안에 벽 타일과 바닥 타일이 있다면, 이 둘은 같은 팔레트 내에서 색상을 찾아야만 합니다. 이것이 바로 NES 그래픽의 특징이자, 우리의 던전 생성 알고리즘에 가장 큰 제약이 될 겁니다!
3.  **패턴 테이블 (Pattern Tables)**: 0x0000-0x1FFF. 256개의 8x8 픽셀 타일(1KB) 두 세트가 저장됩니다. 하나는 배경(Background)용, 다른 하나는 스프라이트(Sprite)용이죠. 이 256개의 타일 안에서 던전을 구성하는 모든 그래픽 요소(벽, 바닥, 문, 아이템 등)를 표현해야 합니다.

결국, 우리는 32x30 타일 크기의 맵 안에서, 256개의 타일 셋을 활용하여, 2x2 타일 블록 단위로 팔레트 제약을 받는 던전을 만들어야 하는 겁니다. 이건 단순한 '맵 생성'이 아니라, '색상 퍼즐'에 가까워요!

---

### **Code & Logic: 속성 테이블, 네 이놈!**

자, 이제 이 지옥 같은(?) 제약을 뚫고 던전을 만들어 봅시다. 핵심은 '속성 테이블'을 어떻게 처리할 것인가입니다. 일반적인 던전 생성은 그냥 타일을 막 때려 박으면 되지만, NES는 그렇게 녹록지 않아요.

**1단계: 논리적 던전 레이아웃 생성**

먼저 NES VRAM 제약과는 별개로, 던전의 기본적인 구조(방, 복도, 문 등)를 만듭니다. 이 단계는 일반적인 로그라이크 던전 생성 알고리즘(예: 셀룰러 오토마, BSP 트리, 단순 방/복도 연결 방식)과 동일합니다.

```pseudo
// 던전 논리적 맵 정의 (32x30 타일 크기에 맞춰)
const int DUNGEON_WIDTH = 32;
const int DUNGEON_HEIGHT = 30;

enum TileType { WALL, FLOOR, DOOR, ROOM_EDGE, CORRIDOR_EDGE };
TileType LogicalMap[DUNGEON_WIDTH][DUNGEON_HEIGHT];

// 1. 초기화: 모든 타일을 WALL로 채운다.
InitializeLogicalMap() {
    for (y = 0; y < DUNGEON_HEIGHT; y++) {
        for (x = 0; x < DUNGEON_WIDTH; x++) {
            LogicalMap[x][y] = WALL;
        }
    }
}

// 2. 방 생성 (예시)
GenerateRooms(numRooms) {
    for (i = 0; i < numRooms; i++) {
        // 무작위 위치/크기의 방을 생성 (DUNGEON_WIDTH/HEIGHT 내에서)
        // 방 내부를 FLOOR로, 가장자리를 ROOM_EDGE로 표시
    }
}

// 3. 복도 연결 (예시)
ConnectRooms() {
    // 각 방을 복도로 연결 (최소 신장 트리 등)
    // 복도 경로를 FLOOR로, 복도 가장자리를 CORRIDOR_EDGE로 표시
}

// 메인 논리적 생성 함수
GenerateLogicalDungeon() {
    InitializeLogicalMap();
    GenerateRooms(5); // 5개의 방 생성
    ConnectRooms();
    // 필요하다면 trap, item placement 등...
}
```

**2단계: 속성 테이블 팔레트 할당 (이것이 핵심!)**

이제 우리가 NES의 VRAM 제약을 느끼는 순간입니다. 논리적 던전 레이아웃이 완성되면, 이를 기반으로 2x2 타일 블록 단위의 속성 테이블에 팔레트를 할당해야 합니다. NES는 총 4개의 배경 팔레트를 사용할 수 있었고, 각 팔레트가 3가지 고유 색상(백그라운드 컬러 제외)을 가졌죠.

가장 좋은 방법은, 던전의 특정 영역(예: 방 하나, 복도 섹션)에 특정 팔레트를 "테마"로 할당하는 것입니다. 아니면, 2x2 블록 내에서 가장 "지배적인" 타일 유형(벽이 많으면 벽 테마 팔레트, 바닥이 많으면 바닥 테마 팔레트)을 기반으로 할당할 수도 있습니다.

```pseudo
// NES 속성 테이블 제약사항
const int NES_ATTRIBUTE_BLOCK_SIZE = 2; // 2x2 타일 = 1 속성 블록
const int ATTRIBUTE_MAP_WIDTH = DUNGEON_WIDTH / NES_ATTRIBUTE_BLOCK_SIZE; // 16
const int ATTRIBUTE_MAP_HEIGHT = DUNGEON_HEIGHT / NES_ATTRIBUTE_BLOCK_SIZE; // 15
const int NUM_BACKGROUND_PALETTES = 4; // NES 배경 팔레트 개수

// 팔레트 ID 정의 (0~3)
enum PaletteID { PAL_DUNGEON_STONE, PAL_MOSS_CAVE, PAL_FIRE_TEMPLE, PAL_WATER_SHRINE };

// 속성 맵: 각 2x2 블록에 할당될 팔레트 ID
PaletteID AttributeMap[ATTRIBUTE_MAP_WIDTH][ATTRIBUTE_MAP_HEIGHT];

// 타일셋: 팔레트 ID별로 사용 가능한 타일 집합
// 예: Tileset[PAL_DUNGEON_STONE][WALL_TILE_INDEX] -> 특정 돌벽 타일
// 이 Tileset은 사전에 NES 팔레트 규칙에 맞춰 디자인되어야 합니다.
Map<PaletteID, Map<TileType, List<int>>> PredefinedTileset; // int는 패턴 테이블 인덱스

AssignAttributePalettes() {
    for (ay = 0; ay < ATTRIBUTE_MAP_HEIGHT; ay++) {
        for (ax = 0; ax < ATTRIBUTE_MAP_WIDTH; ax++) {
            // 해당 2x2 블록 내의 논리적 타일 유형 분석
            int wallCount = 0;
            int floorCount = 0;
            for (dy = 0; dy < NES_ATTRIBUTE_BLOCK_SIZE; dy++) {
                for (dx = 0; dx < NES_ATTRIBUTE_BLOCK_SIZE; dx++) {
                    int x = ax * NES_ATTRIBUTE_BLOCK_SIZE + dx;
                    int y = ay * NES_ATTRIBUTE_BLOCK_SIZE + dy;
                    if (LogicalMap[x][y] == WALL || LogicalMap[x][y] == ROOM_EDGE || LogicalMap[x][y] == CORRIDOR_EDGE) {
                        wallCount++;
                    } else if (LogicalMap[x][y] == FLOOR || LogicalMap[x][y] == DOOR) {
                        floorCount++;
                    }
                }
            }

            // 지배적인 타일 유형에 따라 팔레트 할당 (매우 단순화된 예시)
            if (wallCount > floorCount) {
                AttributeMap[ax][ay] = ChooseRandomPaletteFrom([PAL_DUNGEON_STONE, PAL_MOSS_CAVE]); // 벽 위주 팔레트
            } else {
                AttributeMap[ax][ay] = ChooseRandomPaletteFrom([PAL_FIRE_TEMPLE, PAL_WATER_SHRINE]); // 바닥/특징 위주 팔레트
            }
            // 실제로는 방/복도 구분, 인접 블록 팔레트와의 조화 등을 고려해야 합니다.
            // 예를 들어, 한 방에는 단일 팔레트를 할당하거나, 복도와 방의 경계 팔레트 충돌을 피해야 합니다.
        }
    }
}
```

**3단계: 최종 타일맵 생성 및 패턴 테이블 인덱스 할당**

이제 논리적 맵과 할당된 속성 팔레트 정보를 바탕으로 실제 NES 패턴 테이블(타일셋)의 인덱스를 Map에 채워 넣습니다. 여기서 중요한 건, **해당 타일의 2x2 속성 블록에 할당된 팔레트에 맞는 타일만 선택**해야 한다는 겁니다.

```pseudo
// 최종 NES 타일맵 (패턴 테이블 인덱스 저장)
int FinalNESMap[DUNGEON_WIDTH][DUNGEON_HEIGHT];

FillFinalNESMap() {
    for (y = 0; y < DUNGEON_HEIGHT; y++) {
        for (x = 0; x < DUNGEON_WIDTH; x++) {
            // 해당 타일이 속한 2x2 속성 블록의 팔레트 ID를 가져온다.
            int ax = x / NES_ATTRIBUTE_BLOCK_SIZE;
            int ay = y / NES_ATTRIBUTE_BLOCK_SIZE;
            PaletteID assignedPalette = AttributeMap[ax][ay];

            // 논리적 타일 유형에 따라 적절한 타일 ID를 선택한다.
            // 이때 반드시 assignedPalette에 호환되는 타일셋에서 선택해야 한다.
            switch (LogicalMap[x][y]) {
                case WALL:
                case ROOM_EDGE:
                case CORRIDOR_EDGE:
                    // PredefinedTileset[assignedPalette][WALL]에서 무작위 타일 ID 선택
                    FinalNESMap[x][y] = GetRandomTileID(PredefinedTileset[assignedPalette][WALL]);
                    break;
                case FLOOR:
                    // PredefinedTileset[assignedPalette][FLOOR]에서 무작위 타일 ID 선택
                    FinalNESMap[x][y] = GetRandomTileID(PredefinedTileset[assignedPalette][FLOOR]);
                    break;
                case DOOR:
                    // PredefinedTileset[assignedPalette][DOOR]에서 무작위 타일 ID 선택
                    FinalNESMap[x][y] = GetRandomTileID(PredefinedTileset[assignedPalette][DOOR]);
                    break;
                default:
                    FinalNESMap[x][y] = 0; // 기본 빈 타일 또는 에러 타일
                    break;
            }
        }
    }
}

// 전체 던전 생성 과정
GenerateCompleteNESDungeon() {
    GenerateLogicalDungeon();
    AssignAttributePalettes();
    FillFinalNESMap();

    // 이제 FinalNESMap에 NES 에뮬레이터나 실제 하드웨어에 로드할 수 있는 타일 데이터가 완성됩니다.
    // AttributeMap은 각 2x2 블록의 팔레트 정보를 담고 있습니다.
}
```

---

**개발자 유머 타임:** "이쯤 되면 '던전 생성'이 아니라 '팔레트 색깔 맞추기 게임' 같다고요? 맞아요! NES 개발자들은 다들 숨겨진 미술 천재이자 최적화 마스터였다니까요! 요즘 개발자들이 이런 제약 속에서 뭘 만들어낼지 생각하면, 벌써부터 제 머릿속 회로가 터질 것 같습니다! 후후."

---

### **결론: 제약 속의 창의성, 그 8비트의 매력**

오늘 우리는 단순한 레트로 감성을 넘어, NES라는 8비트 기기의 하드웨어 제약(특히 VRAM과 속성 테이블) 속에서 어떻게 기능적인 로그라이크 던전을 생성할 수 있는지 그 원리와 구체적인 알고리즘 로직을 파고들어 봤습니다. 이 과정에서 우리는:

1.  **2KB VRAM**의 압박 속에서 네임테이블과 패턴 테이블의 역할을 이해하고, 맵 크기를 제한해야 함을 알았고,
2.  가장 까다로운 **속성 테이블(2x2 타일 블록 팔레트)**의 제약을 극복하기 위해 논리적 맵과 팔레트 할당 단계를 분리하여 접근했습니다.
3.  사전에 **팔레트 호환성을 고려하여 디자인된 타일셋**의 중요성까지 짚어 보았죠.

이 모든 과정은 "어떻게 하면 더 멋진 그래픽을 넣을까?"가 아니라, "어떻게 하면 이 제약 속에서 의도한 결과물을 만들어낼까?"에 대한 깊은 고민입니다. 이런 제약들이 오히려 독특하고 창의적인 게임 플레이와 아트 스타일을 탄생시키는 원동력이 되기도 합니다.

그러니 혹시 여러분 중에 NES 감성 그대로의 로그라이크를 꿈꾸는 개발자가 있다면, 이 괴짜 천재의 팁이 부디 여러분의 VRAM을 지켜주는 든든한 등대가 되기를 바랍니다! 자, 그럼 이만! 저도 제 다음 정신 나간 프로젝트를 구상하러 가야겠습니다! 히히히!
