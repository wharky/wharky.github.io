---
layout: post
title: "망할 픽셀! PS1 저주받은 유산, 유니티에서 부활시키기 (feat. '고정 시점' 던전 자동 생성)"
categories: tech
---

### ⚠️ Image Generation Failed
```text
Prompt: A glitched-out, low-poly PS1-style horror game room. Distorted textures with vibrant pixel art. A ghostly wireframe character stands in a fixed camera perspective, revealing procedural generation blueprints overlaying the scene. Visual artifacts like vertex wobbling and texture warping are prominent. Ethereal light sources cast sharp, angular shadows. A sense of digital decay and nostalgic horror. Octane render, highly detailed.
```


음, 거기 너희들! 또 한밤중에 이상한 코딩 늪에서 허우적대는구만? 나는 (자칭) 천재 게임 개발자, '닥터 글리치'! 오늘은 영혼까지 끌어모아 PS1 시대의 '버그'이자 '매력'이었던 그 불완전한 아름다움을 현대 유니티 엔진 위에서 재현하고, 심지어 그걸로 '고정 시점' 던전까지 자동으로 때려 박는 미친 프로젝트를 해볼 거야. 일종의… 디지털 고고학이지.

우리가 파헤칠 재료는 이 세 가지야: **Retro Console Architecture (PS1)**, **Procedural Generation Algorithms**, 그리고 **Unity Engine Tricks**. 이 셋을 엮어 아주 *고통스럽게* 구체적인 주제를 선정했다. 바로 이거야!

**"유니티에서 PS1 '고정 시점' 바이오하자드식 방을 절차적으로 생성하고, 그 위에서 '정점 스내핑'과 '아핀 텍스처 매핑'을 에뮬레이션하는 방법"**

뭐? 왜 하필 이렇게 괴상하냐고? "재미있잖아, 친구들!" 현대 GPU가 깔끔하게 처리하는 걸 굳이 망쳐놓는 건 예술의 경지라고! 자, 그럼 이 망할 역사의 현장 속으로 다이브해보자!

---

### 1. PS1 그래픽의 '추악한' 진실 (그리고 그 아름다움)

현대 게이머들은 PS1의 '삐걱거리는' 3D 그래픽을 보면 "왜 이렇게 못 만들었지?" 하고 생각할 거야. 하지만 그게 아니라고! 당시 하드웨어의 한계가 낳은 독특한 시그니처였어.

*   **정점 스내핑 (Vertex Snapping / Wobble)**: PS1 GPU는 정점 좌표를 화면 공간에서 *정수*로 처리했어. 부동 소수점 정밀도가 낮았지. 이 때문에 카메라나 오브젝트가 미세하게 움직이면, 정점들이 화면 픽셀 그리드에 맞춰 '딱딱' 붙었다 떨어지면서 흔들리는 것처럼 보였어. 이게 바로 그 유명한 '정점 워블'이야. 마치 화면이 살아있는 것처럼 꿈틀거리는 효과를 줬지.
*   **아핀 텍스처 매핑 (Affine Texture Mapping)**: 요즘 GPU는 투시 보정(Perspective Correction)을 해서, 멀리 있는 면이나 경사진 면의 텍스처가 자연스럽게 보이도록 해. 하지만 PS1 GPU는 그런 거 몰라! 그냥 삼각형의 꼭짓점 UV를 선형적으로 보간했어. 결과적으로 카메라에 비스듬한 면에선 텍스처가 늘어나거나 찌그러지는 현상이 발생했지. 멀리 있는 벽이 '흐느적'거리는 모습, 기억나?

이 두 가지 '버그'는 당시 게임에 독특한 분위기를 부여했어. 특히 호러 게임들은 이 불완전함에서 오는 기괴함을 적극 활용했지. 우리가 이걸 유니티에서 재현할 거란 말이야!

### 2. 고정 시점 방의 절차적 생성: '공포의 지하실' 알고리즘

바이오하자드 같은 고정 시점 게임들은 공간 설계가 아주 중요해. 정해진 카메라 앵글이 주는 긴장감과 퍼즐 요소가 핵심이니까. 이걸 절차적으로 생성하는 건 좀 까다롭지만, 불가능은 아니야.

**목표**: 사전에 정의된 '방 조각' (코너, 벽, 문 등)을 기반으로, 몇 개의 고정된 카메라 앵글을 가질 수 있는 2D 그리드 기반의 방 레이아웃을 생성한다.

**[알고리즘 로직 - '프랑켄슈타인 룸' 생성기]**

1.  **방 그리드 초기화**:
    *   `GRID_SIZE = 10x10` (예: 10x10 타일)
    *   `Grid[x, y]`를 모두 '빈 공간'으로 초기화.
2.  **코어 룸 생성**:
    *   중앙에 `MIN_ROOM_SIZE` (예: 3x3) 크기의 사각형 방을 생성한다.
    *   `Grid`에 '바닥' 타일을 배치한다.
3.  **방 확장 및 벽 생성**:
    *   `MAX_EXPANSION_ITERATIONS` (예: 5회) 동안 다음을 반복:
        *   현재 방의 '벽' 타일 중 하나를 무작위로 선택한다.
        *   이 벽에 인접한 '빈 공간' 타일이 있다면, 그곳에 새로운 '바닥' 타일을 추가하고, 주변에 '벽' 타일을 배치하여 방을 확장한다.
        *   확장 시, 방의 형태가 너무 단순해지지 않도록 'L자' 또는 'T자' 형태의 확장을 유도하는 규칙을 추가할 수 있다 (예: 특정 방향으로만 2칸 이상 확장 금지).
4.  **문(Door) 배치**:
    *   `NUM_DOORS` (예: 2~3개) 만큼 다음을 반복:
        *   방의 '벽' 타일 중 무작위로 하나를 선택한다.
        *   이 벽 타일이 충분히 넓은 공간에 있고, 이미 문이 없는 위치라면, '문' 타일로 교체한다.
        *   문은 반드시 '출구' 또는 '입구' 역할을 할 수 있어야 한다 (나중에 방들을 연결할 때).
5.  **소품(Prop) 및 장애물 배치**:
    *   `PROP_DENSITY` (예: 0.1, 전체 타일의 10%) 만큼 다음을 반복:
        *   '바닥' 타일 중 무작위로 하나를 선택한다.
        *   선택된 타일이 플레이어 이동 경로를 막지 않도록 확인하고, '장애물' (상자, 책상 등) 또는 '장식' (화분, 그림 등) 소품을 배치한다.
        *   **핵심**: 고정 시점을 고려하여, 소품이 카메라 시야를 너무 많이 가리지 않도록 위치 제한을 둔다.
6.  **카메라 트리거 존 배치 (후처리)**:
    *   생성된 방의 주요 코너나 긴 복도에 `CameraZone`을 배치한다.
    *   각 `CameraZone`은 미리 정의된 `VirtualCamera` 프리셋과 연결된다.

**[의사 코드: GenerateSingleRoom()]**

```
FUNCTION GenerateSingleRoom(width, height, minRoomSize, maxIterations, numDoors, propDensity)
    GRID = new Grid[width, height]
    InitializeGrid(GRID, "EMPTY")

    // 1. 코어 룸 생성
    start_x = width / 2 - minRoomSize / 2
    start_y = height / 2 - minRoomSize / 2
    FOR x FROM start_x TO start_x + minRoomSize - 1
        FOR y FROM start_y TO start_y + minRoomSize - 1
            GRID[x, y] = "FLOOR"
        END FOR
    END FOR

    // 2. 방 확장
    FOR i FROM 1 TO maxIterations
        // 무작위로 '벽' 타일 선택 (FLOOR에 인접한 EMPTY)
        // 선택된 벽 주변 EMPTY에 FLOOR 추가 및 새로운 벽 생성
        // (복잡도를 위해 이 부분은 간략화, 실제로는 BFS/DFS로 확장 가능성 탐색)
        ExpandRoomRandomly(GRID)
    END FOR

    // 3. 벽으로 감싸기
    FOR x FROM 0 TO width - 1
        FOR y FROM 0 TO height - 1
            IF GRID[x, y] == "FLOOR" AND HasAdjacent("EMPTY", x, y, GRID)
                PlaceWallSegment(x, y, GRID) // FLOOR와 EMPTY 경계에 벽 배치
            END IF
        END FOR
    END FOR

    // 4. 문 배치
    FOR i FROM 1 TO numDoors
        door_placed = FALSE
        WHILE NOT door_placed
            rand_x, rand_y = GetRandomWallPosition(GRID)
            IF IsValidDoorPlacement(rand_x, rand_y, GRID)
                GRID[rand_x, rand_y] = "DOOR"
                door_placed = TRUE
            END IF
        END WHILE
    END FOR

    // 5. 소품 배치
    FOR i FROM 1 TO width * height * propDensity
        prop_placed = FALSE
        WHILE NOT prop_placed
            rand_x, rand_y = GetRandomFloorPosition(GRID)
            IF IsPathClearAround(rand_x, rand_y, GRID) // 플레이어 이동 방해 안 하는지 확인
                GRID[rand_x, rand_y] = ChooseRandomPropType()
                prop_placed = TRUE
            END IF
        END WHILE
    END FOR

    // 6. Unity 오브젝트로 변환 (타일 기반 Instantiate)
    InstantiateUnityRoom(GRID)
    PlaceCameraTriggers(GRID) // 미리 정의된 카메라 앵글에 맞춰 트리거 배치

    RETURN GRID
END FUNCTION
```
이 알고리즘은 기본적인 룸 레이아웃을 제공해. 실제로는 각 그리드 셀에 해당하는 프리팹 (벽 조각, 바닥 타일, 문 프리팹 등)을 `Instantiate`하고, `Mesh Combiner` 같은 걸 써서 드로우콜을 최적화해야겠지. (으윽, 드로우콜이라니, PS1은 그런 거 신경 안 썼는데!)

### 3. 유니티 엔진 트릭: PS1 비주얼 재현의 마법 (그리고 고통)

자, 이제 이 엉성하게 만들어진 방에 PS1의 '괴랄한' 영혼을 불어넣을 차례야. 우리는 유니티의 렌더 파이프라인과 셰이더를 조작할 거야.

#### 3.1. 정점 스내핑 (Vertex Snapping) 구현

이건 주로 **커스텀 버텍스 셰이더**에서 이루어져. 정점을 월드 공간에서 화면 공간으로 변환한 다음, 화면 공간에서 그 좌표를 양자화(quantize)하는 거지.

**[Unity Shader Logic - Vertex Shader]**

```glsl
// Custom Vertex Shader for PS1 Vertex Snapping Effect
// (Standard RP, URP, HDRP 모두 유사한 원리)

Varyings vert (Attributes input)
{
    Varyings output;

    // 1. 월드 공간 정점 -> 클립 공간 정점 변환
    // UNITY_MATRIX_MVP는 Model-View-Projection 행렬 (Unity 제공)
    float4 clipPos = mul(UNITY_MATRIX_MVP, float4(input.position, 1.0));

    // 2. 클립 공간에서 화면 좌표 양자화 (픽셀 그리드에 스내핑)
    // _ScreenSnapFactor는 인스펙터에서 조절 가능한 변수 (예: 1.0 = 1픽셀, 2.0 = 0.5픽셀 단위 스냅)
    // 여기서 .w 값(perspective depth)은 건드리지 않아. 정점만 흔들릴 뿐.
    float snapValueX = floor(clipPos.x * _ScreenSnapFactor) / _ScreenSnapFactor;
    float snapValueY = floor(clipPos.y * _ScreenSnapFactor) / _ScreenSnapFactor;

    // 양자화된 X, Y 값을 원래 클립 포지션에 적용
    clipPos.x = snapValueX;
    clipPos.y = snapValueY;

    output.vertex = clipPos; // 양자화된 정점 위치 출력
    output.uv = input.uv;    // UV는 그대로 전달
    // ... 다른 버텍스 데이터 (노멀, 컬러 등) 처리 ...

    return output;
}
```

이 셰이더를 적용하면 오브젝트가 움직일 때 정점들이 '틱틱' 끊기면서 흔들리는 PS1 특유의 워블링을 재현할 수 있어. `_ScreenSnapFactor`를 조절해서 스내핑 강도를 바꿀 수 있지. 숫자가 클수록 더 잘게 쪼개져서 덜 티 나고, 작을수록 (예: 0.5) 더 거칠게 스내핑 돼. 마치 PS1 GPU가 알코올 중독으로 손을 떠는 것 같지!

#### 3.2. 아핀 텍스처 매핑 (Affine Texture Mapping) 에뮬레이션

이건 조금 더 '속임수'가 많이 필요해. 현대 GPU는 태생적으로 투시 보정을 하거든. 이걸 강제로 꺼버리는 건 쉽지 않아. 하지만 *비슷한 시각적 왜곡*을 만들어낼 수는 있지.

**핵심 트릭**: 프래그먼트 셰이더에서 투시 보정된 UV를 사용하지 않고, 화면 공간 UV를 기반으로 텍스처를 샘플링하는 거야.

**[Unity Shader Logic - Vertex/Fragment Shader]**

```glsl
// Custom Shader for PS1 Affine Texture Mapping Effect Approximation

// Vertex Shader (부분)
Varyings vert (Attributes input)
{
    Varyings output;
    // (위에서 구현한 정점 스내핑 코드 삽입 가능)
    float4 clipPos = mul(UNITY_MATRIX_MVP, float4(input.position, 1.0));

    // 중요한 부분: 클립 공간 X, Y와 W 값을 프래그먼트 셰이더로 보낸다.
    // 이 값들은 GPU에 의해 선형적으로 보간될 것이며, 우리가 이걸 이용해서 투시 보정을 우회할 거야.
    output.clipSpacePosition = clipPos; // float4(x, y, z, w)
    output.uv = input.uv; // 기본적인 UV도 일단 전달
    // ... 다른 데이터 ...
    return output;
}

// Fragment Shader (부분)
float4 frag (Varyings input) : SV_Target
{
    // 1. 프래그먼트 셰이더에서 보간된 클립 공간 좌표 가져오기
    float4 interpolatedClipPos = input.clipSpacePosition;

    // 2. '가짜' 화면 공간 UV 계산 (투시 보정 우회)
    // 이렇게 하면 clip.w로 나누는 과정이 없어지거나, 다르게 적용되어
    // 마치 투시 보정 없이 선형 보간된 UV처럼 보이게 된다.
    // GPU가 clipPos.xy와 clipPos.w를 개별적으로 선형 보간하므로,
    // (interpolatedClipPos.xy / interpolatedClipPos.w)는 이미 투시 보정된 UV임.
    // 우리가 원하는 건 투시 보정이 '없는' UV!
    // -> 이 방법 대신 '스크린 공간 UV'를 직접 계산해서 사용하는 것이 더 효과적이다.
    
    // 다시 생각해본다: PS1의 아핀 매핑은 Z 버퍼링이 없던 초기에 UV를 Z값으로 나누지 않고 보간해서 생기는 현상.
    // 현대 GPU에서는 Z로 UV를 나누는 과정(perspective divide)이 자동으로 일어난다.
    // 이 자동 과정을 '회피'해야 한다.
    // 가장 직접적인 방법은 셰이더에서 UV를 '수동으로' Z값으로 나누고 다시 곱하는 과정을 통해
    // GPU의 자동 보정을 교란하는 것이다.

    // A. 가장 간단한 시각적 근사:
    // 텍스처 해상도를 낮추고 필터링 모드를 'Point'로 설정한다.
    // 이것만으로도 많은 레트로 게임에서 비슷한 느낌을 줬다.
    // 그리고 위에 구현한 Vertex Snapping이 왜곡 효과를 극대화한다.

    // B. 좀 더 적극적인 왜곡 (고오급 기법!):
    // Vertex Shader에서 clipPos.xy / clipPos.w 를 계산해서 UV로 넘겨준다 (투시 보정된 화면 공간 UV).
    // Fragment Shader에서는 이 UV를 사용하되, 추가적인 조작을 가한다.
    // 혹은 Vertex Shader에서 아예 다른 기준으로 UV를 계산해서 전달하는 방법.
    // 다음은 screen-space UV를 활용한 왜곡 근사치다.

    // [개선된 Affine Approximation Logic]
    // 1. Vertex Shader에서 ClipSpacePosition.xy와 ClipSpacePosition.w를 따로 넘겨준다.
    //    이때 .xy는 clip.w에 의해 나눠지지 않은 상태로 넘겨져야 한다 (linear interpolate).
    //    그리고 fragment shader에서 .xy를 .w로 나눔으로써 투시 보정을 '제어'한다.

    // Vertex Shader:
    // output.screenPosUnDivided = clipPos.xy; // 클립 공간 XY
    // output.wForPerspective = clipPos.w;   // 클립 공간 W (depth for perspective)

    // Fragment Shader:
    float2 affineUV = input.screenPosUnDivided / input.wForPerspective; // 여기서 투시 보정 적용
    
    // 이 affineUV는 사실 현대 GPU의 기본 UV와 거의 동일할 수 있다.
    // 그럼에도 불구하고, PS1의 '느낌'을 주는 핵심은 'UV가 선형적으로 보간될 때 발생하는 왜곡'이다.
    // 현대 GPU는 UV를 (U/W, V/W) 형태로 보간하여 투시 보정을 한다.
    // PS1은 U, V를 보간하고 마지막에 Z를 나눴다.

    // 가장 '직관적인' PS1 아핀 매핑의 시각적 재현은
    // 1. 낮은 해상도 텍스처 + Point 필터링
    // 2. Vertex Snapping으로 인한 기하학적 불안정성
    // 3. 그리고, 셰이더에서 UV를 '의도적으로' 깊이(Z)에 따라 비례하지 않게 왜곡시키는 것이다.
    
    // Fragment Shader (실용적인 왜곡 효과 추가)
    // input.uv는 이미 투시 보정된 UV이다. 이 UV를 '다시' 왜곡시킨다.
    // 예를 들어, 깊이에 따라 UV 스케일을 조정하거나 오프셋을 주는 방식.
    float depthFactor = 1.0 / input.clipSpacePosition.w; // 카메라와의 상대적 깊이
    float2 distortedUV = input.uv * (1.0 + (_AffineDistortionStrength * (1.0 - depthFactor)));
    // _AffineDistortionStrength는 인스펙터 변수.
    // 깊이에 따라 UV가 비선형적으로 늘어나거나 줄어들도록 조작.

    float4 col = tex2D(_MainTex, distortedUV); // 왜곡된 UV로 텍스처 샘플링
    // ... 색상 처리 ...
    return col;
}
```
여기서 `_AffineDistortionStrength` 같은 변수를 통해 왜곡 정도를 조절할 수 있어. 이건 완벽한 아핀 매핑의 에뮬레이션이라기보다는, PS1에서 보던 '텍스처가 흐느적거리는' 시각적 효과를 재현하는 트릭에 가까워. 완벽한 재현은 하드웨어 단의 에뮬레이션이 더 적합하지만, 게임 개발에선 이런 시각적 속임수가 더 실용적이지. "정답이 어딨어? 좋으면 그만이지!"

#### 3.3. 고정 시점 카메라 로직: '빅 브라더'의 시선

유니티에서 고정 시점 카메라는 `Cinemachine`을 사용하면 아주 쉽게 구현할 수 있어.

**[Unity Trick - Cinemachine 사용]**

1.  **여러 개의 `Cinemachine Virtual Camera` 생성**: 방의 주요 위치마다 `VirtualCamera`를 배치하고 원하는 앵글과 FOV를 설정한다.
2.  **`CinemachineBrain` 설정**: 메인 카메라에 `CinemachineBrain` 컴포넌트를 추가하고, 블렌딩 시간을 설정한다 (카메라 전환 시 부드럽게 전환될지, 즉시 스냅될지).
3.  **트리거 볼륨 설정**: 각 `VirtualCamera`에 해당하는 영역에 `Collider`를 만들고 `Is Trigger`를 체크한다.
4.  **스크립트로 전환 제어**: 플레이어가 트리거 볼륨에 들어가면 해당 `VirtualCamera`를 활성화한다.

**[C# 스크립트 - CameraZone.cs]**

```csharp
using UnityEngine;
using Cinemachine; // Cinemachine 네임스페이스 추가

public class CameraZone : MonoBehaviour
{
    public CinemachineVirtualCamera targetCamera; // 이 존에 진입하면 활성화할 가상 카메라
    public float blendTime = 1.0f; // 카메라 전환 시간

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Player")) // 플레이어가 트리거에 들어오면
        {
            // 모든 가상 카메라 비활성화
            foreach (CinemachineVirtualCamera cam in FindObjectsOfType<CinemachineVirtualCamera>())
            {
                cam.enabled = false;
            }
            
            // 타겟 가상 카메라 활성화
            if (targetCamera != null)
            {
                targetCamera.enabled = true;
                // CinemachineBrain의 기본 블렌딩을 사용할 경우, 이 부분은 생략 가능
                // 아니면 CinemachineBrain.SetTransition(targetCamera, blendTime) 같은 메서드를 사용.
            }
        }
    }
    
    // (옵션) 트리거를 나갈 때 이전 카메라로 돌아가거나 기본 카메라를 활성화하는 로직 추가
    // private void OnTriggerExit(Collider other) { ... }
}
```

이걸 각 방의 카메라 전환 지점에 배치하면, 플레이어가 움직일 때마다 '찰칵'하고 시점이 바뀌면서 그 시절의 향수를 자극할 거야. 마치 누군가 우리를 계속 훔쳐보는 듯한 불쾌한 감시 시점... 완벽하잖아!

---

자, 여기까지 PS1 시대의 '괴짜' 그래픽을 유니티에 이식하고, 그 위에서 절차적 방 생성을 통해 '고정 시점' 공포 게임의 뼈대를 만드는 법을 알아봤어. 이걸 가지고 뭘 만들지는 너희들의 몫이야. 저주받은 인형의 집? 미궁 속의 실험실? 아니면 그냥 PS1 향수를 뿜어내는 '추억의 방'?

기억해. 좋은 코드는 버그가 없는 코드가 아니야. *매력적인 버그*를 만들 줄 아는 코드가 진짜라고! 이제 가서 너희만의 괴작을 만들어보라고, 괴짜 천재들아! 다음번엔 좀 더 미쳐버린 주제로 돌아오겠다! 쿠하하하!
