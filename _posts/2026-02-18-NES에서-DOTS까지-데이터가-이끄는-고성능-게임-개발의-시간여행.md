---
layout: post
title: "NES에서 DOTS까지: 데이터가 이끄는 고성능 게임 개발의 시간여행"
categories: tech
---

### ⚠️ Image Generation Failed
```text
Prompt: Abstract depiction of an old 8-bit console microchip's data flow merging with a futuristic, holographic representation of a data-oriented architecture (DOTS). Cinematic lighting, deep blues and purples, circuit board patterns transforming into dynamic data streams, retro pixel art elements subtly interwoven, highly detailed, octane render, concept art.
```

안녕하세요, 동료 개발자 여러분! 오늘 제가 커피 한 잔 마시며 풀어볼 이야기는, 얼핏 들으면 전혀 관계없어 보이는 두 가지 키워드의 결합입니다. 바로 'Retro Console Architecture (NES/SNES/PS1)' 그리고 'Data-Oriented Technology Stack (DOTS)'. 8비트의 향수를 자극하는 추억의 콘솔 아키텍처와, Unity 엔진의 미래이자 고성능 게임 개발의 핵심인 DOTS. 이 둘 사이에 무슨 연결고리가 있냐고요? 제 오랜 개발 경험에 비추어 보면, 이 둘은 시대를 초월하여 '데이터 효율성'이라는 같은 본질을 꿰뚫고 있다는 것을 알 수 있습니다.

### 🕰️ 과거의 문제: 제약 속에서 피어난 데이터 중심 설계

우리가 흔히 '레트로'라고 부르는 NES, SNES, 그리고 PS1 같은 초기 콘솔들은 말 그대로 '제약의 예술'이었습니다. 요즘 개발자들은 상상하기 힘들 정도로 낮은 클럭의 CPU, 몇 킬로바이트(KB) 수준의 RAM, 그리고 극도로 제한된 VRAM과 버스 대역폭이 전부였죠.

**문제:** 이 제한된 자원 속에서 어떻게 복잡한 게임 로직을 구현하고, 수많은 스프라이트를 화면에 그려내며, 음악까지 동시에 재생할 수 있었을까요? 특히, CPU가 매 프레임 모든 화면 요소를 직접 처리하려 했다면, 아마 게임은 슬라이드 쇼가 되었을 겁니다.

**해결책: 하드웨어 주도형 데이터 구조**
이 시기의 개발자들은 선택의 여지 없이 하드웨어의 특성을 최대한 활용해야 했습니다. CPU가 단순히 명령을 처리하는 '뇌'였다면, PPU(Picture Processing Unit)나 APU(Audio Processing Unit) 같은 전용 칩셋들은 특정 종류의 데이터를 매우 효율적으로 처리하는 '특화된 팔다리'였습니다. 그리고 이 칩셋들이 효율적으로 작동하기 위해서는 데이터가 특정 형태로, 특정 위치에 존재해야만 했죠.

예를 들어, NES의 **OAM (Object Attribute Memory)**을 떠올려 봅시다. 64개의 스프라이트를 위한 256바이트짜리 이 작은 메모리 공간은, 각 스프라이트의 Y/X 좌표, 타일 인덱스, 속성(팔레트, 플립, 우선순위)을 밀도 높게 담고 있었습니다. CPU는 단지 이 OAM 데이터를 매 프레임 업데이트해주면 되었고, PPU는 이 **연속된 데이터 블록**을 직접 읽어 화면에 스프라이트를 그려냈습니다. CPU의 개입 없이, PPU는 OAM이라는 '데이터 덩어리'를 자기 방식대로 빠르게 처리했죠.

```c
// NES OAM Entry (Simplified)
typedef struct {
    uint8_t y_position;    // 스프라이트의 Y 좌표
    uint8_t x_position;    // 스프라이트의 X 좌표
    uint8_t tile_index;    // 스프라이트 패턴 테이블 인덱스
    uint8_t attributes;    // 팔레트, 우선순위, 가로/세로 플립 등
} SpriteOAMEntry;

// 전체 OAM은 64개의 SpriteOAMEntry로 구성된 연속된 메모리 공간
SpriteOAMEntry OAM[64];

// CPU는 매 프레임 OAM 데이터를 업데이트
void UpdateSpritePosition(uint8_t sprite_id, uint8_t x, uint8_t y) {
    OAM[sprite_id].x_position = x;
    OAM[sprite_id].y_position = y;
}

// PPU (하드웨어)는 OAM 배열을 직접 읽어 스프라이트를 렌더링
// CPU 개입 없이 연속된 데이터를 고속으로 처리
```

이것은 요즘 말하는 '데이터 지향' 설계의 원초적인 형태였습니다. 데이터가 CPU의 주도적인 로직 처리보다는, 특정 하드웨어가 효율적으로 소비할 수 있는 형태로 구성되고 관리되었던 것이죠.

### 🚀 현재의 문제: 추상화 속에서 길을 잃은 데이터

수십 년이 흐른 지금, 우리는 기가헤르츠(GHz) 단위의 멀티코어 CPU와 기가바이트(GB) 단위의 RAM을 사용합니다. 하지만 아이러니하게도, '고성능' 게임 개발은 여전히 어려운 과제입니다.

**문제:** CPU는 빨라졌지만, 메모리 접근 속도는 크게 개선되지 않았습니다. L1, L2, L3 캐시 같은 계층적 메모리 구조는 이 간극을 줄여주지만, 데이터가 캐시에 올라와 있지 않으면 발생하는 '캐시 미스'는 CPU의 클럭 사이클을 어마어마하게 낭비하게 만듭니다. 게다가 객체 지향 프로그래밍(OOP) 패러다임은 데이터와 로직을 캡슐화하는 데는 좋지만, 메모리상에서 데이터를 이리저리 흩어 놓는 경향이 있어 캐시 효율성을 떨어뜨리곤 합니다. 멀티코어 시대에 발맞춰 병렬 처리를 하려 해도, 공유 데이터 관리나 스레드 안전성 문제로 골머리를 썩게 되죠.

**해결책: Data-Oriented Technology Stack (DOTS)**
여기서 Unity의 DOTS가 등장합니다. DOTS는 ECS(Entity Component System), Burst Compiler, C# Job System을 통해 이러한 현대적인 성능 병목 현상을 해결하고자 합니다. 이는 단순히 새로운 기능을 추가하는 것이 아니라, 데이터를 바라보는 관점 자체를 바꾸는 패러다임 전환을 요구합니다.

**DOTS가 어떻게 해결하는가:**
*   **ECS (Entity Component System):** 데이터(Component)와 로직(System)을 분리하고, 엔티티(Entity)는 단순히 데이터 묶음을 식별하는 ID 역할을 합니다. 여기서 중요한 것은, 동일한 컴포넌트 데이터를 메모리상에 최대한 **연속적으로 배치**한다는 점입니다.
*   **Burst Compiler:** C# Job System으로 작성된 코드(주로 순수 데이터 처리 로직)를 LLVM 기반의 고성능 네이티브 코드로 컴파일하여 CPU 최적화를 극대화합니다.
*   **C# Job System:** CPU 코어들을 안전하고 효율적으로 활용하여 병렬 처리를 가능하게 합니다. 공유 데이터를 최소화하고, Job이 필요한 데이터에만 접근하도록 설계됩니다.

결국 DOTS는 현대 CPU의 캐시 효율성을 극대화하고, 멀티코어를 효과적으로 활용하기 위해 데이터를 '가공 가능한 재료'로 보고, 이 재료를 가장 효율적인 방식으로 배치하고 처리하는 데 집중하는 것입니다.

### 🧐 레트로와 DOTS: 시대를 잇는 데이터 중심 설계의 본질

자, 이제 NES의 OAM과 DOTS의 ECS를 다시 비교해봅시다.

**문제점:** 수천 개의 게임 오브젝트(스프라이트, 몬스터, 플레이어 등)가 각각의 변환(Translation), 회전(Rotation), 스케일(Scale), 그리고 스프라이트 정보를 가지고 있다고 가정해 봅시다. 이 데이터들이 메모리 여기저기 흩어져 있다면, 렌더링 시스템이 각 오브젝트를 처리할 때마다 메모리 캐시 미스가 발생하여 성능 저하로 이어집니다.

**DOTS의 해결책 (ECS 기반 렌더링 시스템 예시):**

```csharp
// DOTS Components (IComponentData는 마커 인터페이스)
public struct Translation : IComponentData {
    public float3 Value;
}
public struct Rotation : IComponentData {
    public quaternion Value;
}
public struct SpriteRendererData : IComponentData {
    public int SpriteID; // 스프라이트 아틀라스 내 ID
    public float2 UV0, UV1;
    public Color Color;
}

// DOTS System (Burst Compile 가능한 Job 형태로)
[BurstCompile]
public partial struct RenderSpriteJob : IJobEntity
{
    // 렌더링 명령을 기록할 버퍼 (NativeArray 또는 NativeList)
    public NativeList<RenderCommand> RenderCommands;

    void Execute(in Translation translation, in Rotation rotation, in SpriteRendererData spriteData)
    {
        // 각 엔티티의 컴포넌트 데이터를 읽어 렌더링 명령 생성
        // 'in' 키워드는 데이터 복사를 방지하고 참조로 접근
        float4x4 transformMatrix = float4x4.TRS(translation.Value, rotation.Value, 1f); // 스케일 임시로 1
        RenderCommands.Add(new RenderCommand {
            Matrix = transformMatrix,
            SpriteID = spriteData.SpriteID,
            Color = spriteData.Color
            // ... 기타 필요한 렌더링 정보
        });
    }
}

// 실제 시스템은 위 Job을 스케줄링하고 렌더링 버퍼를 관리
public partial class SpriteRenderSystem : SystemBase
{
    private EndSimulationEntityCommandBufferSystem _endSimulationEcbSystem;
    private NativeList<RenderCommand> _renderCommands;

    protected override void OnCreate()
    {
        _endSimulationEcbSystem = World.GetOrCreateSystemManaged<EndSimulationEntityCommandBufferSystem>();
        _renderCommands = new NativeList<RenderCommand>(Allocator.Persistent);
    }

    protected override void OnUpdate()
    {
        // Job 실행 전 Clear
        _renderCommands.Clear();

        // Job 스케줄링
        var jobHandle = new RenderSpriteJob {
            RenderCommands = _renderCommands
        }.ScheduleParallel(Dependency);

        // Job 완료 대기 및 렌더링
        jobHandle.Complete();

        // _renderCommands에 모인 데이터를 실제 GPU 렌더링 API로 전달
        // (예: Graphics.DrawMeshInstancedIndirect 등을 사용하여 고성능 렌더링)
    }

    protected override void OnDestroy()
    {
        _renderCommands.Dispose();
    }
}

// RenderCommand 구조체 (GPU로 보낼 데이터를 압축)
public struct RenderCommand {
    public float4x4 Matrix;
    public int SpriteID;
    public Color Color;
    // ...
}
```

이 모습, 어디서 많이 본 것 같지 않나요? 그렇습니다. NES PPU가 OAM을 처리하던 방식과 놀랍도록 닮아 있습니다. CPU(또는 System)는 필요한 데이터를 한 번에 모아(ECS Chunks), 이를 특정 목적을 가진 프로세서(Burst Compiled Job, PPU)에게 넘겨주고, 이 프로세서는 **연속적으로 배치된 데이터를 고속으로 처리**하는 방식.

과거에는 하드웨어의 물리적 제약이 이런 데이터 지향적 설계를 강요했다면, 현대 DOTS는 CPU의 아키텍처적 특성(캐시)과 병렬 처리의 이점을 최대한 살리기 위해 **의도적으로** 이런 데이터 중심 설계를 선택합니다. 본질은 동일한 셈이죠.

### 🤔 시니어 개발자의 의견: 과거에서 배우는 미래

저는 DOTS를 처음 접했을 때, 단순히 'Unity의 새로운 고성능 아키텍처' 정도로 생각했습니다. 하지만 레트로 콘솔 개발의 역사와 비교해보니, DOTS는 단순한 기술 스택이 아니라, **개발자들이 잊고 있었던 '데이터의 본질'에 대한 통찰을 다시 불러일으키는 것**이라는 강한 확신을 얻었습니다.

우리는 너무나 쉽게 추상화의 늪에 빠져버립니다. 오브젝트 지향 패러다임은 우리의 생각을 추상적인 개념으로 묶어주는 강력한 도구였지만, 동시에 데이터가 메모리 상에서 어떻게 배치되고 소비되는지에 대한 감각을 무디게 만들었습니다. 이는 마치 거대한 컨베이어 벨트를 설계할 때, 각 부품이 어디에 놓여야 가장 효율적으로 다음 공정으로 넘어갈지를 고민하지 않고, 그저 '부품이 오겠지'라고 막연히 생각하는 것과 같습니다.

레트로 콘솔의 개발자들은 한 바이트, 한 클럭 사이클이 아쉬운 상황에서, 데이터의 물리적 배치와 프로세싱 유닛의 특성을 꿰뚫고 코드를 작성했습니다. 그리고 DOTS는 이 '데이터 중심 사고방식'을 현대적인 도구와 구조를 통해 재현하고 있습니다.

따라서 DOTS를 제대로 이해하고 활용하려면, 단순히 API를 익히는 것을 넘어, 왜 데이터를 이 방식으로 구성해야 하는지, 왜 Job System이 필요한지 등 **그 이면에 숨겨진 '데이터 효율성'에 대한 철학을 이해하는 것이 중요합니다.** 그리고 그 철학의 뿌리는 바로 NES의 256바이트 OAM과 SNES의 타일맵 최적화 같은 레트로 아키텍처에 깊이 박혀있다고 저는 감히 말씀드립니다.

### 🌟 결론: 본질은 변하지 않는다

'Retro Console Architecture'와 'DOTS'는 기술적인 시대는 다르지만, **제한된 자원 속에서 최고의 성능을 이끌어내기 위한 '데이터 중심 사고방식'**이라는 동일한 DNA를 공유합니다. 과거의 개발자들이 하드웨어의 제약 때문에 어쩔 수 없이 데이터 효율성을 극대화했다면, 현대의 DOTS 개발자들은 복잡한 멀티코어 환경에서 소프트웨어적으로 이를 재현하여 극한의 성능을 추구하는 것이죠.

옛것을 본받아 새것을 익힌다는 '온고지신(溫故知新)'의 정신이 게임 개발 분야에도 그대로 적용될 수 있다는 점이 놀랍지 않나요? 레트로 콘솔의 기술적 한계를 들여다보면, DOTS가 왜 이런 형태로 디자인되었는지, 그리고 우리가 왜 데이터 중심적 사고를 해야 하는지에 대한 깊은 통찰을 얻을 수 있습니다.

데이터는 게임 개발의 연료입니다. 그 연료를 어떻게 저장하고, 어떻게 효율적으로 태워야 할지를 고민하는 것이 실력 있는 개발자의 핵심 역량이라고 생각합니다. 자, 오늘부터는 여러분의 코드 속 데이터가 어떤 모양으로 메모리 속에 자리 잡고 있는지, 그리고 누가 그 데이터를 가장 효율적으로 소비하고 있는지 한 번쯤 진지하게 고민해 보는 건 어떨까요?

다음 포스팅에서 또 재미있는 기술 이야기로 찾아뵙겠습니다!
