---
layout: post
title: "PS1의 춤추는 텍스처를 현대 엔진에서 부활시키기: 어핀 텍스처 매핑 왜곡의 심연 (Unity Shader Deep Dive)"
categories: tech
---

![PS1의 춤추는 텍스처를 현대 엔진에서 부활시키기: 어핀 텍스처 매핑 왜곡의 심연 (Unity Shader Deep Dive)](https://image.pollinations.ai/prompt/A+stylized%2C+low-poly+3D+scene+reminiscent+of+early+PlayStation+1+graphics.+A+simplistic%2C+blocky+adventurer+character+stands+on+a+vast%2C+geometrically+patterned+ground+plane.+The+textures+on+the+ground+plane+are+visibly+%27wobbly%27+and+stretched%2C+showing+distinct+affine+texture+mapping+distortion.+The+scene+has+a+nostalgic+yet+slightly+eerie%2C+surreal+atmosphere%2C+with+sharp%2C+angular+shadows+and+a+muted%2C+early-3D+color+palette.+Digital+artifacts+and+geometric+imperfections+are+subtly+highlighted%2C+capturing+the+charm+of+vintage+hardware+limitations.?width=800&height=450&nologo=true&seed=9162)

> **AI Image Prompt:** A stylized, low-poly 3D scene reminiscent of early PlayStation 1 graphics. A simplistic, blocky adventurer character stands on a vast, geometrically patterned ground plane. The textures on the ground plane are visibly 'wobbly' and stretched, showing distinct affine texture mapping distortion. The scene has a nostalgic yet slightly eerie, surreal atmosphere, with sharp, angular shadows and a muted, early-3D color palette. Digital artifacts and geometric imperfections are subtly highlighted, capturing the charm of vintage hardware limitations.

자, 동료 개발자 여러분! 우리는 오늘 타임머신을 타고 게임 역사의 한 페이지로 떠날 겁니다. 바로 '레트로 감성'의 정점을 찍었던 PS1 시대로 말이죠. 아니, 정확히는 PS1이 우리에게 남긴 '아름다운 오류' 중 하나, 바로 춤추고 일그러지는 '어핀 텍스처 매핑 왜곡(Affine Texture Mapping Distortion)'을 다시금 스크린에 소환하는 마법을 부려볼 겁니다. 수십 년 전, 하드웨어의 한계가 빚어낸 이 기묘한 현상을 이제 와서 우리가 직접 코드로 재현한다니, 참 개발자의 삶이란 아이러니하지 않습니까? 과거의 '버그'를 미래의 '특징'으로 만드는 이 변태적인 즐거움을 만끽해 봅시다!

### PS1은 왜 그렇게 '춤'을 췄을까? (Deep Dive: 원리 파고들기)

현대 GPU는 '원근 보정(Perspective Correction)'이라는 엄청난 기술을 사용합니다. 화면 속의 3D 오브젝트가 카메라에 멀어질수록 작아지고, 가까워질수록 커지는 것이 자연스럽죠? 텍스처도 마찬가지입니다. 멀리 있는 텍스처는 압축되어 보이고, 가까운 텍스처는 확장되어 보여야 현실적입니다. 이걸 수학적으로 처리하기 위해, 현대 GPU는 텍스처 좌표 (u, v)를 클립 공간 W 값으로 나눈 (u/w, v/w, 1/w) 값들을 화면 공간에서 선형 보간한 다음, 다시 (1/w)로 나누어 최종적인 원근 보정된 UV를 얻어냅니다. 복잡하죠? 그냥 "똑똑하게 텍스처를 붙인다"고 생각하면 됩니다.

하지만 우리의 사랑스러운 PS1은 달랐습니다! 그 시절의 하드웨어는 그렇게 똑똑하지 못했습니다. PS1은 원근 보정 없이, 그냥 화면 공간(Screen Space)에서 2D 삼각형 위로 텍스처 좌표 (u, v)를 **선형적으로(Affinely)** 보간하여 매핑했습니다. 클립 공간 W 값에 대한 고려가 없었죠.

이게 무슨 결과를 초래했을까요?
*   **가까이 있는 폴리곤**: W 값의 변화가 크지 않아 비교적 괜찮아 보였습니다.
*   **멀리 있거나, 카메라에 대해 기울어진 폴리곤**: W 값의 변화가 커지는데도 불구하고 UV가 선형적으로 보간되니, 텍스처가 마치 고무줄처럼 늘어나거나 찌그러지면서 '일렁이는' 듯한 착시 현상을 일으켰습니다. 특히 바닥 같은 넓고 평평한 면에서 두드러졌죠. "아, 저 바닥 위에서 대체 무슨 일이 일어나고 있는 거야!" 싶을 정도로요.

개발자들은 이 문제를 해결하기 위해 폴리곤을 잘게 쪼개거나 다른 꼼수를 썼지만, 그 특유의 왜곡은 PS1 게임의 아이덴티티가 되었습니다. 그리고 오늘 우리는 이 아이덴티티를 **고의적으로 부활시킬 겁니다!**

### 현대 엔진에서 PS1 텍스처 왜곡 재현하기 (Code & Logic)

Unity의 ShaderLab과 HLSL을 기반으로 이 왜곡을 재현해 봅시다. 핵심은 '원근 보정'을 살짝 비틀어 주는 것입니다. 현대 GPU가 기본적으로 제공하는 원근 보정된 UV 대신, 우리가 의도적으로 '잘못된' UV를 계산해서 사용하면 됩니다.

**기본 아이디어:**
우리는 정점 셰이더(Vertex Shader)에서 클립 공간 W 값을 그대로 보간하여 프래그먼트 셰이더(Fragment Shader)로 넘길 겁니다. 이 W 값은 원근 보정 없이 선형적으로 보간됩니다. 그리고 프래그먼트 셰이더에서 현재 픽셀의 '진정한' 원근 보정 W 값(Unity의 `ComputeScreenPos`가 제공하는 `1/W`의 역수)과 비교하여 UV를 왜곡시킬 것입니다.

---

```hlsl
// Unity ShaderLab - Standard Surface Shader or Unlit Shader for simplicity
Shader "Custom/PS1AffineTexture"
{
    Properties
    {
        _MainTex ("Texture", 2D) = "white" {}
        _Color ("Color", Color) = (1,1,1,1)
    }
    SubShader
    {
        Tags { "RenderType"="Opaque\
