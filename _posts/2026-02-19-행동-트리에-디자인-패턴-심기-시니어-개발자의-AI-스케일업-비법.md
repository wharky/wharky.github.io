---
layout: post
title: "행동 트리에 디자인 패턴 심기: 시니어 개발자의 AI 스케일업 비법"
categories: tech
---

### ⚠️ Image Generation Failed
```text
Prompt: An abstract, high-tech, glowing neural network forming a complex tree structure, symbolizing AI Behavior Trees. Intertwined within the nodes are stylized, subtle outlines of various game design patterns (e.g., gears for strategy, lightning bolts for command). The setting is a dark, futuristic void with dramatic, cinematic lighting in deep blues, purples, and electric greens. Hyper-detailed, digital art, high resolution, inspiring, concept art.
```

안녕하세요, 동료 개발자 여러분! 오늘 제가 여러분과 커피 한 잔 기울이며 나누고 싶은 이야기는 바로 'Game Design Patterns'와 'AI Behavior Trees'라는 두 가지 핵심 키워드의 시너지에 관한 겁니다. 베테랑 개발자라면 익숙할 이 두 개념이 어떻게 만나, 복잡한 게임 AI를 더욱 우아하고 강력하게 만들어주는지, 그 깊이 있는 실무 팁을 공유해볼까 합니다.

### 🤯 문제: '이게 과연 끝인가?' 싶었던 AI 스파게티 코드의 악몽

제가 현업에서 AI를 처음 다루기 시작했을 때를 떠올려보면, 그야말로 '맨땅에 헤딩'의 연속이었습니다. 조건문과 상태 전이가 뒤섞인 코드 덩어리는 마치 미로 같았죠. 겨우겨우 AI를 굴려놓으면, 기획자가 "이 상황에서는 이렇게 해봐야죠!" 한마디 할 때마다 코드를 통째로 뜯어고쳐야 하는 불상사가 비일비재했습니다. 특히 복잡한 적 AI나 NPC의 행동을 구현할 때는, "이게 과연 끝인가?" 싶을 정도로 길고 지루한 디버깅과의 싸움이 이어졌습니다.

그러다 'Behavior Tree (행동 트리)'라는 개념을 접하게 되면서 한 줄기 빛을 본 듯했습니다. 계층적 구조, 시각적인 흐름, 쉬운 확장성... "이거다!" 싶었죠. 하지만 시간이 지나고 AI의 복잡도가 심화될수록, 행동 트리의 '리프 노드(Leaf Node)' 안에 또 다른 스파게티가 만들어지는 경험을 하게 됐습니다. 특정 행동(예: 공격, 방어, 도주)을 구현하는 코드 블록이 너무 커지고, 여러 AI에서 비슷한 로직이 중복되는 문제에 직면한 거죠.

### ✨ 해결: 행동 트리를 더 행동 트리답게, 디자인 패턴으로 숨결 불어넣기

여기서 제가 깨달은 건, 행동 트리는 그 자체로 훌륭한 '디자인 패턴'이지만, 모든 문제의 만병통치약은 아니라는 점입니다. 행동 트리는 AI의 '흐름 제어'와 '결정 구조'를 담당하지만, 개별 행동의 '내부 구현'을 어떻게 가져갈지에 대한 가이드는 부족할 수 있습니다. 바로 이 지점에서 다른 'Game Design Patterns'가 빛을 발합니다. 행동 트리의 노드 하나하나에 디자인 패턴의 철학을 불어넣으면, 유연하고 재사용 가능하며, 기획자 친화적인 AI 시스템을 구축할 수 있습니다.

핵심은 이겁니다: **행동 트리의 리프 노드는 단순한 액션이 아니라, 또 다른 디자인 패턴이 적용된 '마이크로 시스템'이 될 수 있다.**

자, 몇 가지 실용적인 예시를 들어보죠.

#### 🚀 Deep Dive 1: Strategy Pattern으로 AI 행동의 다양성 확보

**문제:** `AttackTarget`이라는 리프 노드가 있습니다. 이 노드는 AI의 무기나 현재 상황(근접, 원거리, 마법 등)에 따라 전혀 다른 공격 방식을 구현해야 합니다. `if-else if`로 가득 찬 `Execute()` 메서드는 빠르게 혼돈에 빠집니다.

**해결:** **Strategy Pattern**을 적용하여 다양한 공격 방식을 캡슐화하고, `AttackTarget` 노드가 상황에 맞는 전략 객체를 '위임(delegate)'하도록 만듭니다.

```cpp
// [Pseudo-code]
// 1. 전략 인터페이스 정의
interface IAttackStrategy {
    void ExecuteAttack(AIContext context, Target target);
}

// 2. 구체적인 전략 구현
class MeleeAttackStrategy implements IAttackStrategy {
    void ExecuteAttack(AIContext context, Target target) {
        // 근접 공격 로직 (칼 휘두르기, 스킬 사용 등)
        Console.WriteLine($"[Melee] AI {context.ID} attacks {target.ID} with sword.");
    }
}

class RangedAttackStrategy implements IAttackStrategy {
    void ExecuteAttack(AIContext context, Target target) {
        // 원거리 공격 로직 (화살 발사, 마법 캐스팅 등)
        Console.WriteLine($"[Ranged] AI {context.ID} attacks {target.ID} with bow.");
    }
}

// 3. 행동 트리 리프 노드: AttackTarget
class AttackTargetNode : BehaviorNode {
    IAttackStrategy currentStrategy;

    public override NodeState Evaluate() {
        // AIContext에서 현재 AI의 무기나 상태를 파악하여 적절한 전략 선택
        if (context.HasMeleeWeapon()) {
            currentStrategy = new MeleeAttackStrategy();
        } else if (context.HasRangedWeapon()) {
            currentStrategy = new RangedAttackStrategy();
        } else {
            return NodeState.FAILURE; // 공격 불가
        }

        currentStrategy.ExecuteAttack(context, context.GetTarget());
        return NodeState.SUCCESS;
    }
}
```

이 방식의 장점은 명확합니다. `AttackTargetNode`는 어떤 공격 로직을 사용할지 몰라도 됩니다. 그저 `IAttackStrategy`를 구현한 객체에게 일을 맡길 뿐이죠. 새로운 공격 방식이 추가되어도 기존 코드를 수정할 필요 없이 새로운 전략 클래스만 만들면 됩니다. 기획자는 이 전략들을 조합하여 AI의 행동을 더욱 풍부하게 설계할 수 있습니다.

#### 🚀 Deep Dive 2: Command Pattern으로 AI 액션과 실행을 분리

**문제:** AI가 특정 행동(예: 스킬 시전, 아이템 사용)을 결정했을 때, 그 행동의 '실제 실행 로직'이 복잡하거나, 비동기적이거나, 다른 시스템(애니메이션, VFX, 네트워크 동기화)과 엮여 있을 수 있습니다. 행동 트리 노드 안에서 이 모든 것을 처리하면 노드가 비대해지고, 테스트하기 어려워집니다.

**해결:** **Command Pattern**을 사용하여 AI의 결정(무엇을 할 것인가)과 실제 실행(어떻게 할 것인가)을 분리합니다. 행동 트리는 '명령을 발행'하고, '명령 처리기(Command Processor)'가 이를 받아 적절히 실행합니다.

```cpp
// [Pseudo-code]
// 1. 명령 인터페이스 정의
interface ICommand {
    void Execute();
    void Undo(); // 되돌리기 기능도 추가할 수 있죠!
}

// 2. 구체적인 명령 구현
class CastSpellCommand : ICommand {
    AIContext context;
    SpellType spell;

    public CastSpellCommand(AIContext ctx, SpellType s) { context = ctx; spell = s; }
    void Execute() {
        // 스킬 시전 로직 (애니메이션 재생, 마나 소모, 이펙트 생성 등)
        Console.WriteLine($"AI {context.ID} casts {spell}.");
        context.PlayAnimation("CastSpell");
        // ... 다른 시스템과 상호작용
    }
    void Undo() { /* 스킬 시전을 되돌리는 로직 (예: 타임 워프!) */ }
}

// 3. 행동 트리 리프 노드: CastSpellNode
class CastSpellNode : BehaviorNode {
    SpellType spellToCast;

    public override NodeState Evaluate() {
        if (!context.CanCastSpell(spellToCast)) {
            return NodeState.FAILURE;
        }

        // 명령 객체를 생성하여 커맨드 큐에 추가
        CommandQueue.Enqueue(new CastSpellCommand(context, spellToCast));
        Console.WriteLine($"AI {context.ID} decides to cast {spellToCast}.");
        return NodeState.SUCCESS;
    }
}

// 4. 별도의 CommandProcessor
class CommandProcessor {
    Queue<ICommand> commandQueue = new Queue<ICommand>();
    void Update() {
        if (commandQueue.Count > 0) {
            ICommand cmd = commandQueue.Dequeue();
            cmd.Execute();
        }
    }
}
```

이 접근 방식은 AI 로직의 '순수성'을 유지하면서, 복잡한 게임 시스템과의 상호작용을 깔끔하게 처리할 수 있게 합니다. 행동 트리는 '무엇을 할지'만 결정하고, '어떻게 할지'는 커맨드 객체와 처리기에게 위임함으로써, 각 계층의 역할을 명확히 분리합니다. 비동기 실행, 되돌리기 기능, 매크로 커맨드 생성 등 다양한 고급 활용이 가능해집니다.

#### 🚀 Deep Dive 3: Observer Pattern으로 반응성 있는 AI 환경 구축

**문제:** AI가 주변 환경 변화(예: 플레이어 등장, 문 열림, 동료 사망)에 실시간으로 반응하게 하려면, 모든 노드에서 끊임없이 상태를 확인해야 합니다. 이는 비효율적이고 행동 트리를 지저분하게 만듭니다.

**해결:** **Observer Pattern**을 활용하여 AI가 특정 이벤트에 '구독'하도록 만듭니다. 관심 있는 이벤트가 발생하면, AI는 즉시 알림을 받고 자신의 행동 트리에 영향을 주거나, 새로운 행동을 유발할 수 있습니다.

```cpp
// [Pseudo-code]
// 1. 이벤트 발행자 인터페이스
interface IEventPublisher {
    void Subscribe(IEventListener listener);
    void Unsubscribe(IEventListener listener);
    void Notify(GameEvent event);
}

// 2. 이벤트 수신자 인터페이스
interface IEventListener {
    void OnEvent(GameEvent event);
}

// 3. AI Controller가 이벤트 수신자로 동작
class AIController : IEventListener {
    BehaviorTree aiBehaviorTree;
    AIContext context;

    public AIController(BehaviorTree bt, AIContext ctx) {
        aiBehaviorTree = bt;
        context = ctx;
        // AI가 특정 이벤트에 관심 있다면 구독
        EventManager.Instance.Subscribe(this, GameEventType.PlayerSpotted);
        EventManager.Instance.Subscribe(this, GameEventType.AllyDown);
    }

    void OnEvent(GameEvent event) {
        switch(event.Type) {
            case GameEventType.PlayerSpotted:
                // 플레이어가 감지되면, AI 컨텍스트 업데이트 및 행동 트리 강제 전환 시도
                context.SetPlayerKnownPosition(event.GetData<Vector3>("position"));
                aiBehaviorTree.ForceActivateBranch(BehaviorTreeBranch.PursuitPlayer);
                break;
            case GameEventType.AllyDown:
                // 동료가 쓰러지면, AI 컨텍스트 업데이트 및 방어 태세 전환
                context.SetThreatLevel(ThreatLevel.High);
                aiBehaviorTree.ForceActivateBranch(BehaviorTreeBranch.DefensiveStance);
                break;
        }
    }

    void Update() {
        aiBehaviorTree.Tick(); // 평소에는 행동 트리 로직 수행
    }
}
```

이 패턴은 AI의 반응성을 크게 향상시키고, 행동 트리를 불필요한 폴링(polling) 로직으로부터 자유롭게 합니다. AI는 자신이 관심 있는 이벤트에만 집중하면 되고, 이벤트 발생 시 즉각적으로 적절한 행동으로 전환하거나 내부 상태를 업데이트할 수 있습니다. 이는 특히 대규모 AI 시스템이나 복잡한 상호작용이 필요한 게임에서 강력한 도구가 됩니다.

### 🏗️ 아키텍처 다이어그램 설명: 패턴들의 조화로운 앙상블

이 모든 패턴들이 어떻게 함께 작동할까요? 상상해보세요:

1.  **AI Controller:** AI의 최상위 관리자입니다. `IEventListener`로서 게임 이벤트를 수신하고, `AIContext`를 업데이트하며, **Behavior Tree**의 루트 노드를 주기적으로 `Tick()`합니다.
2.  **Behavior Tree:** AI의 의사결정 흐름을 시각적으로 구성합니다. `Selector`, `Sequence`, `Parallel` 등의 컴포지트 노드와 `Task` 또는 `Action` 역할을 하는 리프 노드로 이루어져 있습니다.
3.  **Leaf Nodes:** 이곳이 바로 다양한 디자인 패턴이 활약하는 무대입니다.
    *   `AttackTargetNode`는 `Strategy Pattern`을 사용하여 다양한 공격 방식을 유연하게 전환합니다.
    *   `CastSpellNode`나 `UseItemNode`는 `Command Pattern`을 통해 복잡한 실행 로직을 `CommandQueue`에 위임합니다.
    *   `PatrolNode`나 `MoveToNode`는 내부적으로 `PathfindingStrategy`와 같은 또 다른 `Strategy Pattern`을 포함할 수 있습니다.
4.  **AI Context / Blackboard:** AI의 현재 상태, 목표, 주변 정보 등을 담고 있는 중앙 집중식 데이터 저장소입니다. `Observer Pattern`을 통해 업데이트되거나, 행동 트리의 결정에 따라 데이터가 변경됩니다.
5.  **Command Processor / Event Manager:** `Command Pattern`과 `Observer Pattern`의 핵심입니다. AI가 발행한 명령을 실행하고, 게임 이벤트를 구독자들에게 전달합니다.

이러한 구조는 각 부분이 명확한 역할을 가지며, 느슨하게 결합되어 있어 변경과 확장에 매우 용이합니다.

### 👴 나의 주관적인 견해: 패턴, 단순한 기술이 아닌 '사고방식'

제가 이 방법론을 강력하게 추천하는 이유는 단순히 '코드를 더 깔끔하게' 만들 수 있기 때문만은 아닙니다. 디자인 패턴은 개발자에게 '문제 해결의 사고방식'을 제공합니다. 행동 트리를 넘어서 다른 디자인 패턴을 활용하는 것은 다음과 같은 이점을 가져옵니다.

*   **확장성(Scalability):** 새로운 AI 행동이나 규칙을 추가할 때, 기존 코드를 건드리지 않고 새로운 전략이나 커맨드만 추가하면 됩니다.
*   **재사용성(Reusability):** 특정 전략(예: '도망 전략', '엄폐 전략')은 여러 AI 캐릭터에게 재사용될 수 있습니다.
*   **유연성(Flexibility):** 런타임에 AI의 행동 방식을 동적으로 변경하기가 훨씬 쉬워집니다.
*   **테스트 용이성(Testability):** 각 패턴의 구성 요소는 독립적으로 테스트하기 용이하여, AI 디버깅 시간을 획기적으로 줄여줍니다.
*   **기획자 친화성(Designer-Friendliness):** 행동 트리가 추상화된 액션을 보여주고, 그 액션의 세부 구현은 패턴에 의해 깔끔하게 분리되어 있어, 기획자가 AI의 큰 그림을 이해하고 수정하는 데 도움이 됩니다.

물론, 모든 곳에 패턴을 남용하는 것은 '과도한 엔지니어링(Over-engineering)'으로 이어질 수 있습니다. 저도 처음에는 '무조건 패턴!'을 외치다가 오히려 개발 속도가 느려지는 경험을 했죠. 중요한 것은 '어떤 문제가 있고, 그 문제를 이 패턴으로 우아하게 해결할 수 있는가?'라는 질문에 답하며 점진적으로 적용하는 겁니다.

### 맺음말: 더 똑똑하고 아름다운 AI를 향하여

게임 개발은 끊임없이 새로운 도전에 직면하는 여정입니다. 'Game Design Patterns'와 'AI Behavior Trees'의 조합은 단순히 코드 구조를 개선하는 것을 넘어, 우리가 만드는 가상 세계 속 AI들에게 더욱 깊이 있고 생동감 넘치는 행동을 부여하는 강력한 도구가 될 것입니다.

이 포스팅이 여러분의 다음 AI 프로젝트에 작은 영감이라도 되었기를 바랍니다. 혹시 여러분만의 독특한 패턴 활용법이 있다면 댓글로 공유해주세요! 함께 더 똑똑하고 아름다운 AI를 만들어가는 데 기여할 수 있다면, 저에게는 더할 나위 없는 기쁨입니다.

다음에는 또 다른 기술 이야기로 찾아오겠습니다! Happy Coding!
